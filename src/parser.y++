%{
    #include<iostream>
    #include<stdio.h>
    #include "ast.h"
    #include <fstream>
    using namespace std;
    
    extern char* yytext;
    extern int line;
    extern vector<quad> code;

    extern void yyerror(char const*);
    extern void print3AC();
    int yylex (void); 

    FILE* dotfile;
    stack<int> block_stack;

    bool fn_decl = 0;
    int func_flag = 0;
    int dump_tac = 0;
    int dump_sym_table = 0;
    int only_lexer = 0;
    int block_count = 0;
    int Anon_StructCounter=0;
    int if_found = 0;
    int previous_if_found = 0;
    int stop_compiler = 0;		// shows error while parsing
    int isArray = 0;			// true when array is declared
    int type_delim = 0;	

    string funcName = "";
    string className = "";
    string funcType = "";
    string classTemp ="";
    string type = "";
    string storage_class = "";
    vector<string> funcArgs;
    vector<string> idList;
    vector<vector<string> > currArgs(1,vector<string>() );
    vector<qid> initializer_list_values;
    vector<int> array_dims;
    map<string, vector<int>> gotolablelist;
    map<string, int> gotolabel;
    map<string, int> func_usage_map;
    map<string, vector<qid>> global_array_init_map;
    void set_int_type(int);
    void set_real_type();
    int char_int(string str);
    #define YYDEBUG 1
    #define YYERROR_VERBOSE

%}

%union { 
    char* str;
    treeNode* ptr;
    constants* num;
    int ind;
}

%left<str> '(' ')' '{' '}' '[' ']' '.' '+' '-' '*' '/' '%' '&' '|' '^' ',' ';' '<' '>'
%right<str> '~' '!' '?' ':' '=' 
%left<str>  RIGHT_OP LEFT_OP EQ_OP NE_OP  AND_OP OR_OP  LE_OP GE_OP  
%right<str> ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN XOR_ASSIGN OR_ASSIGN UNSIGNED_RIGHT UNSIGNED_RIGHT_ASSIGN

%token<str>integerLiteral stringLiteral nullLiteral characterLiteral textBlock booleanLiteral FloatingPointLiteral Identifier CONTINUE FOR NEW IF PACKAGE SYNCHRONIZED BOOLEAN PRIVATE THIS BREAK DOUBLE THROW BYTE ELSE PUBLIC RETURN INT SHORT CHAR FINAL STATIC VOID CLASS LONG FLOAT SUPER WHILE _ YIELD INC_OP DEC_OP 
%type<ind> NEXT_QUAD

%type<ptr> S G A ChangeTable 
%type<ind> WRITE_GOTO
%type<ptr> AdditiveExpression Name AndExpression ArgumentList ArrayAccess ArrayCreationExpression ArrayInitializer Assignment AssignmentExpression AssignmentOperator Block BlockStatement BlockStatements BreakStatement CastExpression ClassBody ClassBodyDeclaration ClassDeclaration ClassInstanceCreationExpression ClassOrInterfaceTypeToInstantiate CompilationUnit ConditionalAndExpression ConditionalExpression ConditionalOrExpression ConclassorBody ConclassorDeclaration ContinueStatement DimExpr DimExprs Dims EqualityExpression ExclusiveOrExpression ExplicitConclassorInvocation Expression ExpressionStatement FieldAccess FieldDeclaration FloatingPointType ForInit FormalParameter FormalParameterList ForStatement ForStatementNoShortIf ForUpdate  IfThenElseStatement IfThenElseStatementNoShortIf IfThenStatement InclusiveOrExpression IntegralType LabeledStatement LabeledStatementNoShortIf  Literal LocalVariableDeclaration MethodBody MethodDeclaration MethodHeader MethodInvocation MultiplicativeExpression NumericType OrdinaryCompilationUnit PackageDeclaration PostDecrementExpression PostfixExpression PostIncrementExpression PreDecrementExpression PreIncrementExpression Primary PrimaryNoNewArray PrimitiveType RelationalExpression ReturnStatement ShiftExpression Statement StatementExpression StatementExpressionList StatementNoShortIf StatementWithoutTrailingSubstatement StaticInitializer SynchronizedStatement ThrowStatement TopLevelClassOrInterfaceDeclaration TopLevelClassOrInterfaceDeclarations  TypeArgumentsOrDiamond UnaryExpression UnaryExpressionNotPlusMinus UnqualifiedClassInstanceCreationExpression VariableDeclaratorList VariableInitializer VariableInitializerList WhileStatement WhileStatementNoShortIf YieldStatement ClassBodyDeclarations Dimsy ArgumentListy comay ClassBodyy BasicForHeader EnhancedForHeader ForInity Expressiony ForUpdatey TypeArgumentsOrDiamondy ClassOrInterfaceTypeToInstant  Modifiers Modifier SimpleName QualifiedName LeftHandSide VOID2 MethodorConstrDeclarator VariableDeclarator Declarator SimpleName2 Declaration_list IF_CODE EXPR_CODE EXPR_STMT_CODE GOTO_COND GOTO_OR GOTO_AND N

%start CompilationUnit

%%

//grammar for chapter 4

Literal
    : integerLiteral {
        $$=makeleaf($1);
        $$->type = string("int");
        $$->intVal = stoi(string($1));
        $$->expType = 4;
        $$->tempName = string($1);
		sym_entry* temp = new sym_entry;
		$$->place = qid($1, temp);
		$$->nextlist.clear();
    }
    | FloatingPointLiteral {
        $$=makeleaf($1);
        $$->type = string("float");
        $$->realVal = stod(string($1));
        $$->expType = 4;
        $$->tempName = string($1);
		sym_entry* temp = new sym_entry;
		$$->place = qid($1, temp);
		$$->nextlist.clear();
    }
    | booleanLiteral {
        $$=makeleaf($1);
        $$->type = string("boolean");
        if(string($1) == "true") $$->intVal = 1;
        else $$->intVal = 0;
        $$->strVal = string($1);
        $$->expType = 4;
        $$->tempName = string($1);
		sym_entry* temp = new sym_entry;
		$$->place = qid($1, temp);
		$$->nextlist.clear();
    }
    | characterLiteral {
        $$=makeleaf($1);
        $$->type = string("char");
        $$->intVal = char_int(string($1));
        $$->expType = 4;
        $$->tempName = string($1);
		sym_entry* temp = new sym_entry;
		$$->place = qid($1, temp);
		$$->nextlist.clear();
    }
    | stringLiteral {
        $$=makeleaf($1);
        $$->type = string("string");
        $$->strVal = string($1);
        $$->expType = 4;
        $$->tempName = string($1);
		sym_entry* temp = new sym_entry;
		$$->place = qid($1, temp);
		$$->nextlist.clear();
    }
    | textBlock {
        $$=makeleaf($1);
        $$->type = string("textblock");
        $$->tbval = $1;
        $$->expType = 4;
		sym_entry* temp = new sym_entry;
		$$->place = qid($1, temp);
		$$->nextlist.clear();
    }
    | nullLiteral {
        $$=makeleaf($1);
        $$->type = string("null");
        $$->expType = 4;
        $$->tempName = string($1);
		sym_entry* temp = new sym_entry;
		$$->place = qid($1, temp);
		$$->nextlist.clear();
    }
    ;


PrimitiveType
    : NumericType {
        type = $1->type;
        $$ = $1;}
    | BOOLEAN {
        $$ = makeleaf($1);

        // Semantics
        type = $1;
        $$->type = $1;
    }
    ;


NumericType
    : IntegralType {
        $$ = $1;
    }
    | FloatingPointType {
        $$ = $1 ;
    }
    ;

IntegralType   
    : BYTE {
        $$ = makeleaf($1);

        // Semantics
		if(type == "") type = string($1);
		else if(!type_delim) type += " " + string($1);
		$$->type = $1;

    }
    | SHORT {
        $$ = makeleaf($1);

        // Semantics
		if(type == "") type = string($1);
		else if(!type_delim) type += " " + string($1);
		$$->type = $1;
    }
    | INT {
        $$ = makeleaf($1);

        // Semantics
		if(type == "") type = string($1);
		else if(!type_delim) type += " " + string($1);
		$$->type = $1;
    }
    | LONG {
        $$ = makeleaf($1);

        // Semantics
		if(type == "") type = string($1);
		else if(!type_delim) type += " " + string($1);
		$$->type = $1;
    }
    | CHAR {
        $$ = makeleaf($1);

        // Semantics
		if(type == "") type = string($1);
		else if(!type_delim) type += " " + string($1);
		$$->type = $1;
    }
    ;

FloatingPointType
    : FLOAT {
        $$ = makeleaf($1);

        // Semantics
		if(type == "") type = string($1);
		else if(!type_delim) type += " " + string($1);
		$$->type = $1;
    }
    | DOUBLE {
        $$ = makeleaf($1);

        // Semantics
		if(type == "") type = string($1);
		else if(!type_delim) type += " " + string($1);
		$$->type = $1;
    }
    ;

Dims
    :'['']'{
        vector<data>v;
        insertAttr(v, NULL, "[", 0);
        insertAttr(v, NULL, "]", 0);
		$$ = makenode("Dims", v);

        // Semantics
		$$->expType = 2;
        $$->type = "*";

    }
    |'[' ']' Dims{
        vector<data>v;
        insertAttr(v, NULL, "[", 0);
        insertAttr(v, NULL, "]", 0);
        insertAttr(v, $3, "", 1);
		$$ = makenode("Dims", v);

        // Semantics
        if(!$3->is_error){
            $$->expType = 2;
            $$->type = $3->type + "*";
        }
        else {
            $$->is_error = 1;
        }
    }
    ;

//Grammar for Names

Name
    :SimpleName{$$=$1;}
    |QualifiedName{$$=$1;}

SimpleName
    :Identifier{
        $$=makeleaf($1);

        // Semantics
		string temp = primaryExpression(string($1));  
		// if type is there in the symbol table then this means the variable is already declared
		if(temp == ""){
			yyerror(("Undeclared Identifier " + string($1)).c_str());
			$$->is_error = 1;
		}
		else{
			if(temp.substr(0, 5) == "FUNC_"){
				$$->expType = 3;
			}
			else if(temp.back() == '*'){
				$$->expType = 2; 
			}
			else $$->expType = 1;

			if(temp.substr(0,5)=="FUNC_" && temp.back() == '#'){
				temp.pop_back();
				$$->type = temp;
				$$->tempName = string($1); 

                // --3AC 
				$$->nextlist.clear();
			}
			else{

				$$->type = temp;
				$$->isInit = lookup(string($1))->init;
				$$->size = getSize(temp);
				$$->tempName = string($1); 
				
				//--3AC
				$$->place = qid(string($1), lookup(string($1)));
				$$->nextlist.clear();

			}
		}
    }

QualifiedName
    :Name '.' SimpleName{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v,NULL,".",0);
        insertAttr(v, $3, "", 1);
		$$ = makenode("Name.id", v);

        //Semantics
		if(!$1->is_error && $1->expType!=4){
			string temp = string($3->tempName);
			int ret = findTypeAttr($1->type,temp);
			if(ret == -1){
				yyerror(("Class " + $1->node_name + " not defined").c_str());
				$$->is_error = 1;
			}
			else if (ret == 0){
				yyerror(("Class " + $1->type.substr(6, $1->type.length()-6) + " has no member " + string($3->tempName)).c_str());
				$$->is_error = 1;
			}
			else{
				$$->type = StructAttrType($1->type, temp);
				$$->tempName = $1->tempName + "." + temp;
				
				qid temp_var = newtemp($$->type);
				sym_entry* attr_sym = retTypeAttrEntry($1->type, string($3->tempName), $1->tempName);
				emit(qid("member_access", NULL), $1->place, qid(string($3->tempName), attr_sym), temp_var, -1);
				temp_var.second->array_dims = attr_sym->array_dims;
				$$->place = temp_var;
			}
		}
		else{
			if($1->expType==4){
				yyerror("constant expression cannot be used as lvalue");
			}
			$$->is_error = 1;
		}
    }


//start
CompilationUnit
    : OrdinaryCompilationUnit {
        cout << "in compile unit\n";
        vector<data> v;
        insertAttr(v, $1, "", 1);
        // insertAttr(v, makeleaf($2), "", 1);
        $$ = makenode("CompilationUnit",v);

        //  Semantics
        if(($1->is_error )){
            $$->is_error = 1;
        }

        // ...
    }
    ;
    
OrdinaryCompilationUnit
    : PackageDeclaration TopLevelClassOrInterfaceDeclarations {
        vector<data> v;
		insertAttr(v,$1,"",1);
		insertAttr(v,$2,"",1);
		$$ = makenode("Ordinary_Compilation_Unit",v);

        //  Semantics
        if(($1->is_error || $2->is_error)){
            $$->is_error = 1;
        }

        //  ...
    }
    | TopLevelClassOrInterfaceDeclarations {
        $$ = $1;
    }
    ;

TopLevelClassOrInterfaceDeclarations
    : %empty {$$=NULL;}
    | TopLevelClassOrInterfaceDeclaration TopLevelClassOrInterfaceDeclarations {
        cout << "TopLevelClassOrInterfaceDeclarations\n";
        vector<data> v;
		insertAttr(v,$1,"",1);
		insertAttr(v,$2,"",1);
		$$ = makenode("Top_level_class_or_interface_declarations",v);

        //  Semantics
		// if($1->is_error || $2->is_error)	{
		// 	$$->is_error = 1;
		// }
    }
    ;

TopLevelClassOrInterfaceDeclaration
    : ClassDeclaration { $$ = $1;}
    |';' {
        $$ = makeleaf(";");
    }
    ;

PackageDeclaration
    : PACKAGE Name ';' {
        vector<data> v;
		insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,NULL,";",0);
		$$ = makenode("Package_declaration",v);

        // Semantics
        if(!$2->is_error){
            insertSymbol(*curr_table, $1, $2->tempName, 0, 0, NULL);
        }
        else{
            $$->is_error = 1;
        }
    }
    ;

//grammar from classes

ClassDeclaration
    : Modifiers CLASS G S ClassBody {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,$5,"",1);
        $$ = makenode($2,v);

        // Semantics
		if(!$3->is_error && !$5->is_error) {
			if(!currTypeLookup("class_" + string($3->tempName))){
				printStructTable("class_" + string($3->tempName));
				type = "class_" + string($3->tempName);
				$$->type = type;
			}
			else {
				yyerror(("redefinition of " + string($3->tempName)).c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}

    }
    | CLASS G S ClassBody {
        vector<data> v;
        insertAttr(v,$2,"",1);
        insertAttr(v,$4,"",1);
        $$ = makenode($1,v);

        // Semantics
		if(!$2->is_error && !$4->is_error) {
			if(!currTypeLookup("class_" + string($2->tempName))){
				printStructTable("class_" + string($2->type));
				type = string("class_" + string($2->tempName));
				$$->type = type;
			}
			else {
				yyerror(("redefinition of " + string($2->tempName)).c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    ;

Modifiers
    : Modifier {$$=$1;}
    | Modifier Modifiers {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("modifier",v);

        //  Semantics
		if($1->is_error || $2->is_error)	{
			$$->is_error = 1;
		}
        else{
            $$->type = string($1->type + "_" + $2->type);
        }
    }
    ;

Modifier
    :PUBLIC{
        $$=makeleaf($1);
        $$->type = "public";
    }
    |PRIVATE{
        $$=makeleaf($1);
        $$->type = "private";
    }
    |STATIC{
        $$=makeleaf($1);
        $$->type = "static";
    }
    |FINAL{
        $$=makeleaf($1);
        $$->type = "final";
    }
    ;

ClassBody
    : '{' ClassBodyDeclarations '}' {
        $$ = $2;
    }
    ;

ClassBodyDeclarations
    : %empty {$$=NULL;}
    | ClassBodyDeclarations ClassBodyDeclaration{
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Class_Body_Declarations",v);

        // Semantics
        // $$->is_error = $1->is_error || $2->is_error;
    }
    ;

ClassBodyDeclaration
    : FieldDeclaration {$$=$1;}
    | MethodDeclaration {$$=$1;}
    | StaticInitializer {$$=$1;}
    | ConclassorDeclaration {$$=$1;}
    ;

FieldDeclaration
    : Modifiers PrimitiveType VariableDeclaratorList ';' {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,NULL,";",0);
        $$ = makenode("Field_Declaration",v);

        // Semantics
		type = $2->type ;
		className = classTemp;
		type_delim = 0;
		$$->is_error = $1->is_error || $2->is_error || $3->is_error;

    }
    | PrimitiveType VariableDeclaratorList ';' {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,NULL,";",0);
        $$ = makenode("Field_Declaration",v);

        // Semantics
        type = $1->type ;
		className = classTemp;
		type_delim = 0;
		$$->is_error = $1->is_error || $2->is_error;
		
    }
    ;


VariableDeclaratorList
    : VariableDeclarator {
        $$ = $1;
    }
    | VariableDeclaratorList ',' VariableDeclarator {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,NULL,",",0);
        insertAttr(v,$3,"",1);
        $$ = makenode("Variable_Declarator_List",v);

        //  Semantics
        $$->is_error = $1->is_error || $3->is_error; 
    }
    ;

VariableDeclarator
    : Declarator {
        $$ = $1;

		// Semantics
		if (insertStructAttr($1->tempName, $1->type, $1->size, 0) != 1){
			yyerror(("The Attribute " + string($1->tempName) + " is already declared in the same class").c_str());
			$$->is_error = 1;
		} 
    }
    | Declarator '=' VariableInitializer {
        vector<data>v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$3,"",1);
        $$=makenode("=",v);

        // Semantics
        if(assignExp($1->type,$3->type,"=") == ""){
            yyerror("Incorrect type assignment\n");
            $$->is_error = 1;
        }
		if (insertStructAttr($1->tempName, $1->type, $1->size, 1) != 1){
			yyerror(("The Attribute " + string($1->tempName) + " is already declared in the same class").c_str());
			$$->is_error = 1;
		} 
		$$->type=$1->type;
		int num = assign_exp($2, $$->type, $1->type, $3->type, $1->place, $3->place);
		$$->place = $1->place;
		backpatch($3->nextlist, num);
    }
    ;

Declarator
    : Identifier {
        $$ = makeleaf($1);

		// Semantics
        type_delim = 1;
		$$->expType = 1; // Variable
		if(type != "") $$->type = type;
		else {
            yyerror("Unspecified type of the identifier\n");
        }
		$$->tempName = string($1);
		$$->size = getSize(type);

		//3AC
		$$->place = qid(string($1), lookup(string($1)));
    }
    | Declarator '[' ']' {
        vector<data> v;
		insertAttr(v, $1, "", 1);
		insertAttr(v, NULL, "[ ]", 0);
		$$ = makenode("direct_declarator", v);

		// Semantics
		if(!$1->is_error){
			if($1->expType <=2 ) {
				$$->expType = 2;
				$$->type = $1->type + "*";
				$$->tempName = $1->tempName;
				$$->size = 4;	
				$$->intVal = 8;

				//3AC
				$$->place = qid($$->tempName, NULL);
				array_dims.push_back(0);
				isArray = 1;
			}
			else {
				yyerror(( $1->tempName + " declared as function returning an array").c_str());
				$$->is_error = 1;
			}
		}
		else $$->is_error = 1;
    }
    ;

MethodDeclaration
    :MethodHeader MethodBody {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Method_declaration",v);

        // Semantics
        $$->is_error = $1->is_error || $2->is_error;
    }
    ;
MethodHeader
    :Modifiers PrimitiveType MethodorConstrDeclarator{
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Method_Header",v);

        // Semantics
		type = "";
		className = classTemp;
		type_delim = 0;
		$$->is_error = $1->is_error || $2->is_error || $3->is_error;
    }
    |PrimitiveType MethodorConstrDeclarator{
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Method_Header",v);

        // Semantics
		type = "";
		className = classTemp;
		type_delim = 0;
		$$->is_error = $1->is_error || $2->is_error;
    }
    |Modifiers VOID2 MethodorConstrDeclarator{
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Method_Header",v);

        // Semantics
		type = "";
		className = classTemp;
		type_delim = 0;
		$$->is_error = $1->is_error || $2->is_error || $3->is_error;
    }
    |VOID2 MethodorConstrDeclarator{
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Method_Header",v);

        // Semantics
		type = "";
		className = classTemp;
		type_delim = 0;
		$$->is_error = $1->is_error || $2->is_error;
    }
    ;

VOID2  
    : VOID {
        $$ = makeleaf($1);

        // Semantics
		if(type == "") type = string($1);
		else if(!type_delim) type += " " + string($1);
		$$->type = $1;
    }
    ;

MethodorConstrDeclarator
    : SimpleName2 '(' A FormalParameterList ')' NEXT_QUAD {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,NULL,"(",0);
        insertAttr(v,$4,"",1);
        insertAttr(v,NULL,")",0);
        $$ = makenode("Methdod_declarator",v);

		// Semantics
		if(!$1->is_error && !$4->is_error){
			if($1->expType == 1) {
				$$->tempName = $1->tempName;
				$$->expType = 3;
				$$->type = $1->type;
				$$->size = getSize($$->type);

				vector<string> temp = getFuncArgs($1->tempName);
				if(temp.size() == 1 && temp[0] == "#NO_FUNC"){
					insertFuncArg($$->tempName, funcArgs, $$->type);
					funcArgs.clear();
					funcName = string($1->tempName);
					funcType = $1->type;

					//3AC
					$$->place = qid($$->tempName, NULL);
					backpatch($4->nextlist,$6);
					emit(pair<string,sym_entry*>("FUNC_" + $$->tempName + " start :",NULL),pair<string,sym_entry*>("",NULL),pair<string,sym_entry*>("",NULL),pair<string,sym_entry*>("",NULL),-2);
				}
				else{
					// Check if temp is correct
					if(temp == funcArgs){
						funcArgs.clear();
						funcName = string($1->tempName);
						funcType = $1->type;

						//3AC
						$$->place = qid($$->tempName, NULL);
						backpatch($4->nextlist,$6);
						emit(pair<string,sym_entry*>("FUNC_" + $$->tempName + " start :",NULL),pair<string,sym_entry*>("",NULL),pair<string,sym_entry*>("",NULL),pair<string,sym_entry*>("",NULL),-2);
					}
					else {
						yyerror(("Conflicting types for function " + $1->tempName).c_str());
						$$->is_error = 1;
					}
				}
			}
			else {
				if($1->expType == 2){
					yyerror( ($1->tempName + "declared as array of function").c_str());
				}
				else{
					yyerror( ($1->tempName + "declared as function of function").c_str());
				}
				$$->is_error = 1;
			}
		}
		else $$->is_error =1;
	}
	| SimpleName2 '(' A ')' Dimsy {
		vector<data> v;
		insertAttr(v, $1, "", 1);
		insertAttr(v, NULL, "( )", 0);
        if($5 != NULL) insertAttr(v,$5,"",1);
		$$ = makenode("direct_declarator", v);

		// Semantics
		if(!$1->is_error){
			if($1->expType == 1) {
				$$->tempName = $1->tempName;
				$$->expType = 3;
				$$->type = $1->type;
				$$->size = getSize($$->type);

				vector<string> temp = getFuncArgs($1->tempName);
				if((temp.size() == 1 && temp[0] == "#NO_FUNC") || funcArgs == temp){
					insertFuncArg($$->tempName, funcArgs, $$->type);
					funcArgs.clear();
					funcName = string($1->tempName);
					funcType = $1->type;
				}
				else {
					yyerror(("Conflicting types for function " + $1->tempName).c_str());
					$$->is_error = 1;
				}
				//3AC
				$$->place = qid($$->tempName, NULL);
				emit(pair<string,sym_entry*>("FUNC_" + $$->tempName + " start :",NULL),pair<string,sym_entry*>("",NULL),pair<string,sym_entry*>("",NULL),pair<string,sym_entry*>("",NULL),-2);
			}
			else {
				if($1->expType == 2){
					yyerror( ($1->tempName + "declared as array of function").c_str());
				}
				else{
					yyerror( ($1->tempName + "declared as function of function").c_str());
				}
				$$->is_error = 1;
			}
		}
		else $$->is_error = 1;
	}
    ;

SimpleName2
    : Identifier {
        $$ = makeleaf($1);

        // Semantics
        type_delim = 1;
		$$->expType = 1; // Variable
		if(type != "") $$->type = type;
		else {
            yyerror("Undeclared Type\n");
            $$->is_error = 1;
        }
		$$->tempName = string($1);
		$$->size = getSize(type);

		//3AC
		$$->place = qid($$->tempName, NULL);
    }
    ;

VariableInitializer
    : Expression {$$=$1;}
    | ArrayInitializer {$$=$1;}
    ;

Dimsy
    : %empty {$$=NULL;}
    | Dims {$$=$1;}
    ;

FormalParameterList
    : FormalParameter {
        $$ = $1;
    }
    | FormalParameterList ',' NEXT_QUAD FormalParameter {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,NULL,",",0);
        insertAttr(v,$4,"",1);
        $$ = makenode("Formal_Parameter_list",v);

        // Semantics
        if(!$1->is_error && !$4->is_error){
			// 3AC
			backpatch($1->nextlist, $3);
			$$->nextlist = $4->nextlist;
		}
		else $$->is_error = 1;;
    }
    ;


FormalParameter
    : PrimitiveType SimpleName2 Dimsy {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Formal_Parameter",v);

        // Semantics
        if($3 != NULL){
            $2->type = string($2->type + $3->type );
            $2->expType = 2;
        }
		if(!$1->is_error && !$2->is_error){
			type_delim = 0;
			type = "";
			if($2->expType == 1 || $2->expType == 2) {
				if(currLookup($2->tempName)) {
					yyerror(("Redeclaration of Parameter " + $2->tempName).c_str());
					$$->is_error = 1;
				}
				else {
					paramInsert(*curr_table, $2->tempName, $2->type, $2->size, true, NULL);
				}
				funcArgs.push_back($2->type);
			}
		}
		else $$->is_error = 1;
    }
    ;


MethodBody
    : Block {$$=$1;}
    | ';' {$$=makeleaf(";");}
    ;

StaticInitializer
    : STATIC Block {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("StaticInitilizer",v);

        $$->is_error = $2->is_error;
    }
    ;

ConclassorDeclaration
    : Modifiers MethodorConstrDeclarator ConclassorBody {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Conclassor_declaration",v);

        // Semantics
		type = "";
		className = classTemp;
		type_delim = 0;
		$$->is_error = $1->is_error || $2->is_error || $3->is_error;
    }
    ;

ConclassorBody
    : '{' ExplicitConclassorInvocation BlockStatements '}' {
        vector<data> v;
        insertAttr(v,NULL,"{",0);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,NULL,"}",0);
        $$ = makenode("Conclassor_body",v);
    }
    | '{' BlockStatements '}' {
        vector<data> v;
        insertAttr(v,NULL,"{",0);
        insertAttr(v,$2,"",1);
        insertAttr(v,NULL,"}",0);
        $$ = makenode("Conclassor_body",v);
    }
    ;

ExplicitConclassorInvocation
    : THIS '(' ArgumentListy ')' ';' {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,NULL,"(",0);
        insertAttr(v,$3,"",1);
        insertAttr(v,NULL,")",0);
        insertAttr(v,NULL,";",0);
        $$ = makenode("ExplicitConclassorInvocation",v);


    }
    | SUPER '(' ArgumentListy ')' ';' {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,NULL,"(",0);
        insertAttr(v,$3,"",1);
        insertAttr(v,NULL,")",0);
        insertAttr(v,NULL,";",0);
        $$ = makenode("ExplicitConclassorInvocation",v);


    }
    ;

ArgumentListy
    : %empty {$$=NULL;}
    | ArgumentList {$$=$1;}
    ;


comay
    : %empty {$$=NULL;}
    | ',' {$$=makeleaf(",");};
    ;
    
ClassBodyy
    : %empty {$$=NULL;}
    | ClassBody {$$=$1;}
    ;

//10. Arrays

ArrayInitializer
    :'{' VariableInitializerList comay '}'{
        vector<data>v;
        insertAttr(v, NULL, "{", 0);
        insertAttr(v, $2, "", 1);
        insertAttr(v, $3, "", 1);
        insertAttr(v, NULL, "}", 0);
		$$ = makenode("ArrayInitializer", v);
    }
    |'{' comay '}'{
        vector<data>v;
        insertAttr(v, NULL, "{", 0);
        insertAttr(v, $2, "", 1);
        insertAttr(v, NULL, "}", 0);
		$$ = makenode("ArrayInitializer", v);
    }
;

VariableInitializerList
    :VariableInitializer{$$=$1;}
    |VariableInitializerList ',' VariableInitializer  {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ",", 0);
        insertAttr(v, $3, "", 1);
		$$ = makenode("VariableInitializerList", v);
    }
    ;


//14. Productions from (blocks, statements and patterns)

Block
    :'{' ChangeTable BlockStatements '}'{
        $$ =$3;
        
        if(func_flag>=2){
			int bc = block_stack.top();
			block_stack.pop();
			string str = "Block" + to_string(bc);
			string name = funcName+str+".csv";
			printSymbolTable(curr_table, name);
			updSymbolTable(str,0);
			func_flag--;
		}
    }
    ;

BlockStatements
    : %empty {$$=NULL;}
    | BlockStatements NEXT_QUAD BlockStatement {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $3, "", 1);
		$$ = makenode("BlockStatements", v);

        if($1->is_error || $3->is_error)	{
			$$->is_error = 1;
		}

        backpatch($1->nextlist, $2);
        $$->nextlist = $3->nextlist;

        backpatch($1->nextlist, $2);
        $$->nextlist = $3->nextlist;
		$1->caselist.insert($1->caselist.end(), $3->caselist.begin(), $3->caselist.end());
        $$->caselist = $1->caselist;
		$1->continuelist.insert($1->continuelist.end(), $3->continuelist.begin(), $3->continuelist.end());
		$1->breaklist.insert($1->breaklist.end(), $3->breaklist.begin(), $3->breaklist.end());
        $$->continuelist = $1->continuelist;
        $$->breaklist = $1->breaklist;

    }
    ;

BlockStatement
    :Declaration_list {$$=$1;}
    |Statement {$$=$1;} 
    ;

Declaration_list
    : LocalVariableDeclaration ';' {$$=$1;}
    | ClassDeclaration {$$=$1;}
    ;

LocalVariableDeclaration
    :PrimitiveType VariableDeclaratorList{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("LocalVariableDeclaration", v);

        // Semantics
        $$->is_error = $1->is_error || $2->is_error;
    }
    ;


Statement
    :StatementWithoutTrailingSubstatement{$$=$1;}
    |LabeledStatement{$$=$1;}
    |IfThenStatement{$$=$1;}
    |IfThenElseStatement{$$=$1;}
    |WhileStatement{$$=$1;}
    |ForStatement{$$=$1;}
    ;

StatementNoShortIf
    :StatementWithoutTrailingSubstatement{$$=$1;}
    |LabeledStatementNoShortIf{$$=$1;}
    |IfThenElseStatementNoShortIf{$$=$1;}
    |WhileStatementNoShortIf{$$=$1;}
    |ForStatementNoShortIf{$$=$1;}
    ;

StatementWithoutTrailingSubstatement
    :Block{$$=$1;}
    |';'{$$=makeleaf(";");}
    |ExpressionStatement{$$=$1;}
    |BreakStatement{$$=$1;}
    |ContinueStatement{$$=$1;}
    |ReturnStatement{$$=$1;}
    |SynchronizedStatement{$$=$1;}
    |ThrowStatement{$$=$1;}
    |YieldStatement{$$=$1;}
    ;   

LabeledStatement
    : SimpleName ':' NEXT_QUAD Statement{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ":", 0);
        insertAttr(v,$4, "", 1);
		$$ = makenode("LabeledStatement", v);


        //semantic
        if($4->is_error)	{
			$$->is_error = 1;
		}

		if(gotolabel.find($1->tempName) != gotolabel.end()){
			yyerror(string("duplicate label \'" + string($1->tempName) + "\'").c_str());
			$$->is_error = 1;
		}
		else{
			gotolabel.insert({string($1->tempName), $3});
		}
		$$->nextlist = $4->nextlist;
		$$->caselist = $4->caselist;
		$$->continuelist = $4->continuelist;
		$$->breaklist = $4->breaklist;

    }
;

LabeledStatementNoShortIf
    :SimpleName ':' StatementNoShortIf{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ":", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("LabeledStatementNoShortIf", v);
    }
;

ExpressionStatement
    :StatementExpression ';'{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ExpressionStatement", v);
    }
;

StatementExpression
    :Assignment{$$=$1;}
    |PreIncrementExpression{$$=$1;}
    |PreDecrementExpression{$$=$1;}
    |PostIncrementExpression{$$=$1;}
    |PostDecrementExpression{$$=$1;}
    |MethodInvocation{$$=$1;}
    |ClassInstanceCreationExpression{$$=$1;}
;

IF_CODE
    : IF {if_found = 1;} '(' Expression ')' {
        if($4->truelist.empty() && $4->falselist.empty()) {
            int a = code.size();
			backpatch($4->nextlist, a);
            emit(qid("GOTO", NULL),qid("IF", lookup("if")), $4->place, qid("", NULL ),0);
            int b = code.size();
            emit(qid("GOTO", NULL),qid("", NULL), qid("", NULL), qid("", NULL ),0);
            $4->truelist.push_back(a);
            $4->falselist.push_back(b);
        }
        $$ = $4;
		if_found = 0;
    }

IfThenStatement
    :IF_CODE NEXT_QUAD Statement{
        vector<data> v;
		insertAttr(v, $1, "", 1);
		insertAttr(v, $3, "", 1);
		$$ = makenode("if", v);

        // Semantics
		if($1->is_error || $3->is_error)	{
			$$->is_error = 1;
		}

        // 3AC
        backpatch($1->truelist, $2);
		$3->nextlist.insert($3->nextlist.end(), $1->falselist.begin(), $1->falselist.end());
        $$->nextlist= $3->nextlist;
        $$->continuelist = $3->continuelist;
        $$->breaklist = $3->breaklist;
    }
;

IfThenElseStatement
    :IF_CODE NEXT_QUAD StatementNoShortIf N ELSE NEXT_QUAD Statement{
        vector<data> v;
		insertAttr(v, $1, "", 1);
		insertAttr(v, $3, "", 1);
		insertAttr(v, $7, "", 1);
		$$ = makenode("if-else", v);

		if($1->is_error || $3->is_error || $7->is_error)	{
			$$->is_error = 1;
		}

        backpatch($1->truelist, $2);
        backpatch($1->falselist, $6);
		$3->nextlist.insert($3->nextlist.end(), $4->nextlist.begin(), $4->nextlist.end());
		$3->nextlist.insert($3->nextlist.end(), $7->nextlist.begin(), $7->nextlist.end());
        $$->nextlist = $3->nextlist;
		$3->breaklist.insert($3->breaklist.end(), $7->breaklist.begin(), $7->breaklist.end());
		$$->breaklist = $3->breaklist;
		$3->continuelist.insert($3->continuelist.end(), $7->continuelist.begin(), $7->continuelist.end());
		$$->continuelist = $3->continuelist;
    }
;

IfThenElseStatementNoShortIf
    :IF_CODE NEXT_QUAD StatementNoShortIf N ELSE NEXT_QUAD StatementNoShortIf {
        vector<data> v;
		insertAttr(v, $1, "", 1);
		insertAttr(v, $3, "", 1);
		insertAttr(v, $7, "", 1);
		$$ = makenode("if-else", v);

		if($1->is_error || $3->is_error || $7->is_error)	{
			$$->is_error = 1;
		}

        backpatch($1->truelist, $2);
        backpatch($1->falselist, $6);
		$3->nextlist.insert($3->nextlist.end(), $4->nextlist.begin(), $4->nextlist.end());
		$3->nextlist.insert($3->nextlist.end(), $7->nextlist.begin(), $7->nextlist.end());
        $$->nextlist = $3->nextlist;
		$3->breaklist.insert($3->breaklist.end(), $7->breaklist.begin(), $7->breaklist.end());
		$$->breaklist = $3->breaklist;
		$3->continuelist.insert($3->continuelist.end(), $7->continuelist.begin(), $7->continuelist.end());
		$$->continuelist = $3->continuelist;
    }
;

WhileStatement
    : WHILE '(' NEXT_QUAD EXPR_CODE ')' NEXT_QUAD Statement{
        vector<data> v;
		insertAttr(v, $4, "", 1);
		insertAttr(v, $7, "", 1);
		$$ = makenode("while-loop", v);

        // Semantics
		if($4->is_error || $7->is_error)	{
			$$->is_error = 1;
		}
	
        // 3AC
        backpatch($4->truelist, $6);
		$7->nextlist.insert($7->nextlist.end(), $7->continuelist.begin(), $7->continuelist.end());
        backpatch($7->nextlist, $3);
        $$->nextlist = $4->falselist;
        $$->nextlist.insert($$->nextlist.end(), $7->breaklist.begin(), $7->breaklist.end());
        emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), $3);
    }
;

WhileStatementNoShortIf
    : WHILE '(' NEXT_QUAD EXPR_CODE ')' NEXT_QUAD StatementNoShortIf {
        vector<data> v;
		insertAttr(v, $4, "", 1);
		insertAttr(v, $7, "", 1);
		$$ = makenode("while-loop", v);

        // Semantics
		if($4->is_error || $7->is_error)	{
			$$->is_error = 1;
		}
	
        // 3AC
        backpatch($4->truelist, $6);
		$7->nextlist.insert($7->nextlist.end(), $7->continuelist.begin(), $7->continuelist.end());
        backpatch($7->nextlist, $3);
        $$->nextlist = $4->falselist;
        $$->nextlist.insert($$->nextlist.end(), $7->breaklist.begin(), $7->breaklist.end());
        emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), $3);
    }
;

ForStatement
    : BasicForHeader Statement{
        vector<data> v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("For_statement", v);

         //semantic 

        if($1->is_error || $2->is_error)	{
			$$->is_error = 1;
		}

        //3ac
    }
    | EnhancedForHeader Statement{
        vector<data> v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("For_statement", v);

         //semantic 

        if($1->is_error || $2->is_error)	{
			$$->is_error = 1;
		}

        //3ac
    }
;

ForStatementNoShortIf
    : BasicForHeader StatementNoShortIf{
        vector<data> v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("For_statement_no_short_if", v);

        //semantic 

        if($1->is_error || $2->is_error)	{
			$$->is_error = 1;
		}

        //3ac

    }
    | EnhancedForHeader StatementNoShortIf{
        vector<data> v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("For_statement_no_short_if", v);

        //semantic 

        if($1->is_error || $2->is_error) {
			$$->is_error = 1;
		}

        //3ac
    }
;

BasicForHeader
    : FOR '(' ForInity ';' Expressiony ';' ForUpdatey ')' {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ";", 0);
        insertAttr(v,$5, "", 1);
        insertAttr(v, NULL, ";", 0);
        insertAttr(v,$7, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("Basic_For_Header", v);

        //semantic 

        if($3->is_error || $5->is_error || $7->is_error)	{
			$$->is_error = 1;
		}

        //3ac

    }

EnhancedForHeader
    : FOR '(' LocalVariableDeclaration ':' Expression ')' {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ":", 0);
        insertAttr(v,$5, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("Enhanced_For_Header", v);

        //semantic 

        if($3->is_error || $5->is_error)	{
			$$->is_error = 1;
		}

        //3ac
    }

ForInity
    : %empty {$$=NULL;}
    | ForInit {$$=$1;}
    ;

Expressiony
    : %empty {$$=NULL;}
    | Expression {$$=$1;}
    ;

ForUpdatey
    : %empty {$$=NULL;}
    | ForUpdate {$$=$1;}
    ;

ForInit
    :StatementExpressionList{$$=$1;}
    |LocalVariableDeclaration{$$=$1;}
;

ForUpdate
    :StatementExpressionList{$$=$1;}
;

StatementExpressionList
    :StatementExpression{
		$$ = $1;
    }
    |StatementExpression ',' StatementExpressionList{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ",", 0);
        insertAttr(v,$3,"",1);
		$$ = makenode("StatementExpressionList2", v);
    }
;


BreakStatement
    :BREAK SimpleName ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("BreakStatement", v);

        int a = code.size();
        emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
        $$->breaklist.push_back(a);
    }
    |BREAK ';'{
        $$ = makeleaf($1);
        
        int a = code.size();
        emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
        $$->breaklist.push_back(a);
    }
;

YieldStatement
    :YIELD Expression ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("YieldStatement", v);

        // semantics
    }
;

ContinueStatement
    :CONTINUE SimpleName ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ContinueStatement", v);

        // Semantics
        int a = code.size();
        emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
        $$->continuelist.push_back(a);
    }
    |CONTINUE ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ContinueStatement", v);

        // Semantics
        int a = code.size();
        emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
        $$->continuelist.push_back(a);
    }
;

ReturnStatement
    :RETURN Expression ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ReturnStatement", v);

        // Semantics
        if($2->is_error)	{
			$$->is_error = 1;
		}
		backpatch($2->nextlist,code.size());
        emit(qid("RETURN", NULL), $2->place, qid("", NULL), qid("", NULL), -1);
    }
    | RETURN {
        $$ = makeleaf($1);

        // Semantics
        emit(qid("RETURN", NULL), qid("", NULL), qid("", NULL), qid("", NULL), -1);
    }
;

ThrowStatement
    :THROW Expression ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ThrowStatement", v);

        // Semantics
        yyerror("Not implemented yet\n");        
    }
;

SynchronizedStatement
    :SYNCHRONIZED '(' Expression ')' Block{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$5, "", 1);
		$$ = makenode("SynchronizedStatement", v);

        // Semantics
        yyerror("Not implemented yet\n"); 
    }
;

EXPR_CODE
    : {if_found = 1;} StatementExpression {
        if($2->truelist.empty() && $2->falselist.empty()) {
            int a = code.size();
			backpatch($2->nextlist, a);
            emit(qid("GOTO", NULL),qid("IF", lookup("if")), $2->place, qid("", NULL ),0);
            int b = code.size();
            emit(qid("GOTO", NULL),qid("", NULL), qid("", NULL), qid("", NULL ),0);
            $2->truelist.push_back(a);
            $2->falselist.push_back(b);
        }
        $$ = $2;
		if_found = 0;
    }
    ;

EXPR_STMT_CODE
    : {if_found = 1;} ExpressionStatement { 
		if($2->truelist.empty() && $2->falselist.empty()) {
            int a = code.size();
			backpatch($2->nextlist, a);
            emit(qid("GOTO", NULL),qid("IF", lookup("if")), $2->place, qid("", NULL ),0);
            int b = code.size();
            emit(qid("GOTO", NULL),qid("", NULL), qid("", NULL), qid("", NULL ),0);
            $2->truelist.push_back(a);
            $2->falselist.push_back(b);
        }
        $$ = $2;
		if_found = 0;
	}
    ;

N
    : %empty {
        int a = code.size();
		$$ = new treeNode;
        emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
        $$->nextlist.push_back(a);
    }
    ;

//Grammar for Expressions

Primary
    :PrimaryNoNewArray{$$=$1;}
    |ArrayCreationExpression{$$ = $1;}
    ;
PrimaryNoNewArray
    :Literal{$$=$1;}
    |THIS {$$ = makeleaf($1);}
    |'(' Expression ')'{$$=$2;}
    |ClassInstanceCreationExpression{$$=$1;}
    |FieldAccess {$$=$1 ;}
    |ArrayAccess {$$ = $1;}
    |MethodInvocation {$$ = $1;}
    ;


ClassInstanceCreationExpression
    :UnqualifiedClassInstanceCreationExpression {$$ = $1;}
    |Name '.' UnqualifiedClassInstanceCreationExpression{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ClassInstanceCreationExpression", v);
    }
    |Primary '.' UnqualifiedClassInstanceCreationExpression{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ClassInstanceCreationExpression", v);
    }
    ;

UnqualifiedClassInstanceCreationExpression
    :NEW ClassOrInterfaceTypeToInstantiate '(' ArgumentListy ')' ClassBodyy {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, $2, "", 1);
        insertAttr(v, NULL, "(", 1);
        insertAttr(v, $4, "", 1);
        insertAttr(v, NULL, ")", 1);
        insertAttr(v, $6, "", 1);
		$$ = makenode("UnqualifiedClassInstanceCreationExpression", v);
    }
    ;

ClassOrInterfaceTypeToInstantiate
    : SimpleName ClassOrInterfaceTypeToInstant TypeArgumentsOrDiamondy {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ClassOrInterfaceTypeToInstantiate", v);
    }
    ;

TypeArgumentsOrDiamondy
    : %empty {$$=NULL;}
    | TypeArgumentsOrDiamond {$$=$1;}
    ;

ClassOrInterfaceTypeToInstant
    : %empty {$$=NULL;}
    | '.' SimpleName ClassOrInterfaceTypeToInstant  {
        vector<data>v;
        insertAttr(v,NULL,".",0);
        insertAttr(v, $2, "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ClassOrInterfaceTypeToInstant", v);
    }
    ;

TypeArgumentsOrDiamond
    :'<''>'{
        vector<data>v;
        insertAttr(v, NULL, "<", 0);
        insertAttr(v, NULL, ">", 0);
		$$ = makenode("TypeArgumentsOrDiamond", v);
    }
    ;

FieldAccess
    :Primary '.' SimpleName{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v, $3, "", 1);
		$$ = makenode("FieldAccess", v);
    }
    |SUPER '.' SimpleName{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("FieldAccess", v);
    }
    ;

ArrayAccess
    :Name '[' Expression ']' {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "[", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, "]", 0);
		$$ = makenode("ArrayAccess", v);
    }
    |PrimaryNoNewArray '[' Expression ']'{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "[", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, "]", 0);
		$$ = makenode("ArrayAccess", v);
    }

    ;

MethodInvocation
    :Name '(' ArgumentListy ')' {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("MethodInvocation", v);
    }
    |Primary '.' SimpleName '(' ArgumentListy ')' {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$5, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("MethodInvocation", v);
    }
    |SUPER '.' SimpleName '(' ArgumentListy ')' {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$5, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("MethodInvocation", v);
    }
;

ArgumentList
    : Expression {
        $$=$1;

        if(!$1->is_error){
			//Semantic
			$$->isInit = $1->isInit;
			currArgs.back().push_back($1->type);
			$$->type = "void";

			//--3AC
		}
		else{
			$$->is_error = 1;
		}
    }
    |ArgumentList ',' Expression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,NULL, ",", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ArgumentList", v);

        //semantic
        if(!($1->is_error || $3->is_error)){
			string temp = argExp($1->type, $3->type, 2);

			if($1->isInit && $3->isInit) $$->isInit=1;
			currArgs.back().push_back($3->type);
			$$->type = "void";

			//--3AC
		}
		else{
			$$->is_error = 1;
		}
    }

ArrayCreationExpression
    :NEW PrimitiveType DimExprs Dimsy {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("ArrayCreationExpression", v);
    }
    |NEW PrimitiveType Dims ArrayInitializer {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("ArrayCreationExpression", v);
    }
    ;

DimExprs
    :DimExpr{$$=$1;}
    |DimExprs DimExpr{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("DimExprs", v);
    }
    ;


DimExpr
    :'[' Expression ']' {
        vector<data>v;
        insertAttr(v, NULL, "[", 0);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, "]", 0);
		$$ = makenode("DimExpr", v);
    }
    ;

Expression
    :AssignmentExpression {$$ = $1;}
    ;


AssignmentExpression
    :Assignment {$$ = $1;}
    |ConditionalExpression {$$ = $1;}
    ;

Assignment
    :LeftHandSide AssignmentOperator {if_found = 0;} AssignmentExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("Assignment", v);

        //Semantics
		string temp = assignExp($1->type,$4->type,string($2->tempName));

		if(!$1->is_error && !$4->is_error && $1->expType!=4){
			if(!temp.empty()){
				if(temp =="ok"){
					$$->type = $1->type;
				}
				else if(temp == "warning"){
					$$->type = $1->type;
				} 
				if($1->expType == 3 && $4->isInit){
					updInit($1->tempName);
				}
				
				// 3ac 
				int num = assign_exp($2->tempName, $$->type, $1->type, $4->type, $1->place, $4->place);
				$$->place = $1->place;
				backpatch($4->nextlist, num);
			}
			else{
				yyerror(("Incompatible types when assigning " + $4->type + " type to " + $1->type).c_str());
				$$->is_error = 1;
			}
		}
		else{
			if($1->expType==4){
				yyerror("Left operand in assignment operation cannot be a constant expression");
			}
			$$->is_error = 1;
		}
    }
    ;

LeftHandSide
    :Name {$$ = $1;}
    |FieldAccess{$$=$1;}
    |ArrayAccess{$$=$1;}
    ;

AssignmentOperator
    :'='{$$ = makeleaf("=");
    $$->tempName = "=";}
    |DIV_ASSIGN {$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |MUL_ASSIGN {$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |MOD_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |ADD_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |SUB_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |LEFT_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |RIGHT_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |UNSIGNED_RIGHT_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |AND_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |XOR_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
    |OR_ASSIGN{$$ = makeleaf($1);
    $$->tempName = string($1);
    }
;

ConditionalExpression
    : GOTO_COND NEXT_QUAD Expression WRITE_GOTO ':' NEXT_QUAD ConditionalExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ":", 0);
        insertAttr(v,$7, "", 1);
		$$ = makenode("ConditionalExpression2", v);

        // Semantics
		string temp = condExp($3->type, $7->type);

		if(!$1->is_error && !$3->is_error && !$7->is_error){
			if(!temp.empty()){

				if_found = previous_if_found;
				$$->type = "int";
				if($1->intVal) $$->intVal = $3->intVal;
				else $$->intVal = $7->intVal;
				if($1->isInit==1 && $3->isInit==1 && $7->isInit==1) $$->isInit=1;

				// 3AC
				qid temp1 = newtemp($$->type);

				backpatch($1->truelist, $2);
				backpatch($1->falselist, $6);
				backpatch($3->nextlist, $4-1);
				backpatch($3->truelist, $4-1);
				backpatch($3->falselist, $4-1);

				code[$4-1].arg1 = $3->place;
				code[$4-1].res = temp1;

				backpatch($7->nextlist, code.size());
				backpatch($7->falselist, code.size());
				backpatch($7->truelist, code.size());

				emit(qid("=", NULL), $7->place, qid("", NULL), temp1, -1);
				$$->nextlist.push_back($4);
				$$->place = temp1;
			}
			else {
				yyerror("type mismatch in conditional expression");
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}

    }
    |ConditionalOrExpression {$$=$1;}
    ;

GOTO_COND
	: ConditionalOrExpression '?' {
		previous_if_found = if_found;
		if_found = 0;
		$$ = $1;
		if(!$1->is_error){
			if($1->truelist.empty()){
				backpatch($1->nextlist, code.size());
				emit(qid("GOTO", NULL), qid("IF", lookup("if")), $1->place, qid("", NULL), 0);
				$1->truelist.push_back(code.size()-1);
				emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
				$1->falselist.push_back(code.size()-1);
			}
		}
		else $$->is_error = 1;
	}
	;

WRITE_GOTO
	: %empty {
		emit(qid("=", NULL), qid("", NULL), qid("", NULL), qid("", NULL), -1);
		emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
		$$ = code.size()-1;
	}
	;

ConditionalOrExpression
    : GOTO_OR NEXT_QUAD ConditionalAndExpression	{
		vector<data> attr;
		insertAttr(attr, $1, "", 1);
		insertAttr(attr, $3, "", 1);
		$$ = makenode("||",attr);

		// Semantics

		if(!$1->is_error && !$3->is_error){
			$$->type = string("int");
			$$->isInit = (($1->isInit) & ($3->isInit));   
			$$->intVal = $1->intVal || $3->intVal;

			// 3AC
			if($3->truelist.empty() && if_found){
				backpatch($3->nextlist, code.size());
				emit(qid("GOTO", NULL), qid("IF", lookup("if")), $3->place, qid("", NULL), 0);
				$3->truelist.push_back(code.size()-1);
				emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
				$3->falselist.push_back(code.size()-1);
			}
			else {
				qid tmp = newtemp($$->type);
				emit(qid("||", NULL), $1->place, $3->place, tmp, -1);
				$$->place = tmp;
			}
			backpatch($1->falselist, $2);
			$$->truelist = $1->truelist;
			$$->truelist.insert($$->truelist.end(), $3->truelist.begin(), $3->truelist.end());
			$$->falselist = $3->falselist;
		}
		else{
			$$->is_error = 1;
		}
	}
    |ConditionalAndExpression { $$ = $1 ; }
    ;

GOTO_OR
	: ConditionalOrExpression OR_OP {
		$$ = $1;
		if(!$1->is_error){
			if($1->truelist.empty() && if_found){
				backpatch($1->nextlist, code.size());
				emit(qid("GOTO", NULL), qid("IF", lookup("if")), $1->place, qid("", NULL), 0);
				$1->truelist.push_back(code.size()-1);
				emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
				$1->falselist.push_back(code.size()-1);
			}
		}
		else $$->is_error = 1;
		
	}
	;

ConditionalAndExpression
    :GOTO_AND NEXT_QUAD InclusiveOrExpression {
		vector<data> attr;
		insertAttr(attr, $1, "", 1);
		insertAttr(attr, $3, "", 1);
		$$ = makenode("&&",attr);

		// Semantics
		if(!$1->is_error && !$3->is_error){
			$$->type = string("int");
			$$->isInit = (($1->isInit) & ($3->isInit));   
			$$->intVal = $1->intVal && $3->intVal;

			// 3AC
			if($3->truelist.empty() && if_found){
				backpatch($3->nextlist, code.size());
				emit(qid("GOTO", NULL), qid("IF", lookup("if")), $3->place, qid("", NULL), 0);
				$3->truelist.push_back(code.size()-1);
				emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
				$3->falselist.push_back(code.size()-1);
			}
			else {
				qid tmp = newtemp($$->type);
				emit(qid("&&", NULL), $1->place, $3->place, tmp, -1);
				$$->place = tmp;
			}
			backpatch($1->truelist, $2);
			$$->truelist = $3->truelist;
			$$->falselist = $1->falselist;
			$$->falselist.insert($$->falselist.end(), $3->falselist.begin(), $3->falselist.end());
		}
		else{
			$$->is_error = 1;
		}
	}
    |InclusiveOrExpression { $$ = $1 ;}
    ;

GOTO_AND
	: ConditionalAndExpression AND_OP {
		$$ = $1;
		
		if(!$1->is_error){
			if($1->truelist.empty() && if_found){
				backpatch($1->nextlist, code.size());
				emit(qid("GOTO", NULL), qid("IF", lookup("if")), $1->place, qid("", NULL), 0);
				$1->truelist.push_back(code.size()-1);
				emit(qid("GOTO", NULL), qid("", NULL), qid("", NULL), qid("", NULL), 0);
				$1->falselist.push_back(code.size()-1);
			}
		}
		else $$->is_error = 1;
	}
	;

InclusiveOrExpression
    :InclusiveOrExpression '|' ExclusiveOrExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "|", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("InclusiveOrExpression", v);

        //Semantics
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = bitExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp =="ok"){
					$$->type = "int";
				}
				else $$->type = "int";
				
				$$->intVal = $1->intVal | $3->intVal;

				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid("|", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1;
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary |").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |ExclusiveOrExpression {$$ = $1;}
    ;
ExclusiveOrExpression
    :ExclusiveOrExpression '^' AndExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "^", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ExclusiveOrExpression", v);

        //Semantics
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = bitExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp =="ok"){
					$$->type = "int";
				}
				else $$->type = "int";

				$$->intVal = $1->intVal ^ $3->intVal;

				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid("^", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1; 
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary ^").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |AndExpression {$$ = $1;}
    ;

AndExpression
    :AndExpression '&' EqualityExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "&", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("AndExpression", v);

        //Semantics
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = bitExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp =="ok"){
					$$->type = "int";
				}
				else $$->type = "int";
				
				$$->intVal = $1->intVal & $3->intVal;

				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid("&", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1;
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary &").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |EqualityExpression {$$ = $1;}
    ;

EqualityExpression
    :EqualityExpression EQ_OP RelationalExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("EqualityExpression", v);

        //Semantics
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = eqExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				$$->type = "int";

				if($1->intVal == $3->intVal) $$->intVal = 1;
				else $$->intVal = 0;

				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid("==", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1;
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary ==").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |EqualityExpression NE_OP RelationalExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("EqualityExpression", v);

        //Semantics
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = eqExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				$$->type = "int";

				if($1->intVal != $3->intVal) $$->intVal = 1;
				else $$->intVal = 0;

				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid("!=", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1; 
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary !=").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}

        
    }
    |RelationalExpression {$$ = $1 ;}
    ;

RelationalExpression
    :RelationalExpression '<' ShiftExpression  {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,NULL, "<", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("RelationalExpression", v);


        //Semantic
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = relExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp == "bool"){
					$$->type = "int";
				}
				else if(temp == "Bool"){
					$$->type = "int";
				}

				if($1->intVal < $3->intVal) $$->intVal = 1;
				else $$->intVal = 0;

				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid("<", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1; 
				}
				$$->nextlist.clear();
				
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary <").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    } 
    |RelationalExpression '>' ShiftExpression  {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,NULL, "<", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("RelationalExpression", v);

        //semantic

		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = relExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp == "bool"){
					$$->type = "int";
				}
				else if(temp == "Bool"){
					$$->type = "int";
				}

				if($1->intVal > $3->intVal) $$->intVal = 1;
				else $$->intVal = 0;
				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid(">", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1; 
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary >").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    } 
    |RelationalExpression GE_OP ShiftExpression  {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("RelationalExpression", v);

        //Semantic
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = relExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp == "bool"){
					$$->type = "int";
				}
				else if(temp == "Bool"){
					$$->type = "int";
				}
				if($1->intVal >= $3->intVal) $$->intVal = 1;
				else $$->intVal = 0;
				// 3AC
				$$->nextlist.clear();
				 
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary >=").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    } 
    |RelationalExpression LE_OP ShiftExpression  {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("RelationalExpression", v);

        //Semantic
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = relExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp == "bool"){
					$$->type = "int";
				}
				else if(temp == "Bool"){
					$$->type = "int";
				}
				if($1->intVal <= $3->intVal) $$->intVal = 1;
				else $$->intVal = 0;
				// 3AC
				$$->nextlist.clear();
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary <=").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |ShiftExpression {$$ = $1;}
    ;


ShiftExpression
    :ShiftExpression LEFT_OP AdditiveExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ShiftExpression", v);

		//Semantic
		if(!$1->is_error && !$3->is_error){
			if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
			string temp = shiftExp($1->type,$3->type);
			if(!temp.empty()){
				$$->type = $1->type;
				$$->intVal = $1->intVal << $3->intVal;
				$$->tempName = $1->tempName + " << " + $3->tempName;

				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid("<<", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1;
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary <<").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}

    }
    |ShiftExpression RIGHT_OP AdditiveExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ShiftExpression", v);

        //Semantic
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		string temp = shiftExp($1->type,$3->type);

		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				$$->type = $1->type;
				$$->intVal = $1->intVal >> $3->intVal;
				$$->tempName = $1->tempName + " >> " + $3->tempName;

				// 3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					emit(qid(">>", NULL), $1->place, $3->place, temp1, -1);
					$$->place = temp1;
				}
				$$->nextlist.clear();
				
			}
			else{
				yyerror(("Invalid operands of types \'" + $1->type + "\' and \'" + $3->type + "\' to binary >>").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |ShiftExpression UNSIGNED_RIGHT AdditiveExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ShiftExpression", v);

        yyerror("Not implemented yet!\n");

    }
    |AdditiveExpression {$$= $1;}
    ;

AdditiveExpression
    :AdditiveExpression '+' MultiplicativeExpression  {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,NULL, "+", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("AdditiveExpression", v);
        
        //Semantic
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
		
		string temp = addExp($1->type,$3->type,'+');
		
		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp == "int")	$$->type = "int";
				else if(temp == "real")	$$->type = "float";
				else $$->type =  temp;

				$$->intVal = $1->intVal + $3->intVal;
				$$->realVal = $1->realVal + $3->realVal;
				$$->tempName = $1->tempName + " + " + $3->tempName;

				// 3AC

				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					int cond1 = (isInt($1->type) && isFloat($3->type));
					int cond2 = (isInt($3->type) && isFloat($1->type));

					if(cond1){
						qid temp2 = newtemp($3->type);
						emit(qid("inttoreal", NULL), $1->place, qid("", NULL), temp2, -1);
						emit(qid("+"+temp, NULL), temp2, $3->place, temp1, -1);
					}
					else if(cond2){
						qid temp2 = newtemp($1->type);
						emit(qid("inttoreal", NULL), $3->place, qid("", NULL), temp2, -1);
						emit(qid("+"+temp, NULL), $1->place, temp2, temp1, -1);
					}
					else{
						emit(qid("+"+temp, NULL), $1->place, $3->place, temp1, -1);
					}
					$$->place = temp1;
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Incompatible types \'" + $1->type + "\' and \'" + $3->type + "\' for + operator").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |AdditiveExpression '-' MultiplicativeExpression  {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,NULL, "-", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("AdditiveExpression", v);

        //Semantic
		if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;

		string temp = addExp($1->type,$3->type,'-');
		if(!$1->is_error && !$3->is_error){
			if(!temp.empty()){
				if(temp == "int")$$->type = "int";
				else if(temp == "real")$$->type = "float";
				else $$->type = temp;

				$$->intVal = $1->intVal - $3->intVal;
				$$->realVal = $1->realVal - $3->realVal;
				$$->tempName = $1->tempName + " - " + $3->tempName;

				// 3AC

				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid temp1 = newtemp($$->type);
					int cond1 = (isInt($1->type) && isFloat($3->type));
					int cond2 = (isInt($3->type) && isFloat($1->type));

					if(cond1){
						qid temp2 = newtemp($3->type);
						emit(qid("inttoreal", NULL), $1->place, qid("", NULL), temp2, -1);
						emit(qid("-"+temp, NULL), temp2, $3->place, temp1, -1);
					}
					else if(cond2){
						qid temp2 = newtemp($1->type);
						emit(qid("inttoreal", NULL), $3->place, qid("", NULL), temp2, -1);
						emit(qid("-"+temp, NULL), $1->place, temp2, temp1, -1);
					}
					else{
						emit(qid("-"+temp, NULL), $1->place, $3->place, temp1, -1);
					}
					$$->place = temp1;
				}
				$$->nextlist.clear();
				
			}
			else{
				yyerror(("Incompatible types \'" + $1->type + "\' and \'" + $3->type + "\' for - operator").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
	}
    |MultiplicativeExpression {$$ = $1;}
    ;


MultiplicativeExpression
    :MultiplicativeExpression '*' UnaryExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,NULL, "*", 1);
        insertAttr(v,$3,"",1);
		$$ = makenode("MultiplicativeExpression", v);

        if(!($1->is_error || $3->is_error)){

			//Semantic
			$$->intVal = $1->intVal * $3->intVal; 

			if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
			string temp = mulExp($1->type, $3->type, '*');

			if(!temp.empty()){
				$$->type = temp;
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					if(temp == "int"){
						$$->type = "int" ;

						//--3AC
						qid q = newtemp("int");
						$$->place = q;
						$$->nextlist.clear();
						emit(qid("*int", NULL), $1->place, $3->place, q, -1);
					}
					else if(temp == "float"){
						$$->type = "float";

						//--3AC

						qid q = newtemp("float");
						$$->place = q;
						$$->nextlist.clear();

						if(isInt($1->type)){
							qid q1 = newtemp($$->type);
							emit(qid("inttoreal", NULL), $1->place, qid("", NULL), q1, -1);

							emit(qid("*real", NULL), q1, $3->place, q, -1);
						}
						else if(isInt($3->type)){
							qid q1 = newtemp($$->type);
							emit(qid("inttoreal", NULL), $3->place, qid("", NULL), q1, -1);
							emit(qid("*real", NULL), $1->place, q1, q, -1);
						}
						else{
							emit(qid("*real", NULL), $1->place, $3->place, q, -1);
						}
					}
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Incompatible types \'" + $1->type + "\' and \'" + $3->type + "\' for * operator").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |MultiplicativeExpression '/' UnaryExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,NULL, "/", 1);
        insertAttr(v,$3,"",1);
		$$ = makenode("MultiplicativeExpression", v);

        if(!($1->is_error || $3->is_error)){
			//Semantic
			if($3->intVal!=0)$$->intVal = $1->intVal / $3->intVal;
			if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
			string temp =mulExp($1->type,$3->type,'/');
			if(!temp.empty()){
				$$->type = temp;

				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					if(temp == "int"){
						$$->type = "int" ;

						//--3AC
						qid q = newtemp("int");
						$$->place = q;
						$$->nextlist.clear();
						emit(qid("/int", NULL), $1->place, $3->place, q, -1);
					}
					else if(temp == "float"){
						$$->type = "float";

						//--3AC
						qid q = newtemp("float");
						$$->place = q;
						$$->nextlist.clear();
						if(isInt($1->type)){
							qid q1 = newtemp($$->type);
							emit(qid("inttoreal", NULL), $1->place, qid("", NULL), q1, -1);

							emit(qid("/real", NULL), q1, $3->place, q, -1);
						}
						else if(isInt($3->type)){
							qid q1 = newtemp($$->type);
							emit(qid("inttoreal", NULL), $3->place, qid("", NULL), q1, -1);

							emit(qid("/real", NULL), $1->place, q1, q, -1);
						}
						else{
							emit(qid("/real", NULL), $1->place, $3->place, q, -1);
						}
					}
				}
				$$->nextlist.clear();
			}
			else{
				yyerror(("Incompatible types \'" + $1->type + "\' and \'" + $3->type + "\' for / operator").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}

    }
    |MultiplicativeExpression '%' UnaryExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,NULL, "%", 1);
        insertAttr(v,$3,"",1);
		$$ = makenode("MultiplicativeExpression", v);

        if(!($1->is_error || $3->is_error)){
			//Semantic
			if($1->isInit ==1 && $3->isInit ==1) $$->isInit = 1;
			if($3->intVal!=0)$$->intVal = $1->intVal % $3->intVal;
			string temp =mulExp($1->type,$3->type,'%');
			if(temp == "int"){
				$$->type = "int" ;

				//--3AC
				if($1->expType == 4 && $3->expType == 4){
					$$->place = qid(to_string($$->intVal), $1->place.second);
					$$->expType = 4;
				}
				else{
					qid q = newtemp("int");
					$$->place = q;
					emit(qid("%", NULL), $1->place, $3->place, q, -1);
				}
				$$->nextlist.clear();

			}
			else{
				yyerror(("Incompatible types \'" + $1->type + "\' and \'" + $3->type + "\' for % operator").c_str());
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}


    }
    |UnaryExpression {$$ = $1;}
    ;


UnaryExpression
    :PreIncrementExpression {$$ = $1;}
    |PreDecrementExpression {$$ = $1;}
    |'+' UnaryExpression {
        // $1=makeleaf("+");
        vector<data>v;
        insertAttr(v, NULL, "+", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("UnaryExpression", v);

        //--3AC
		qid plus=qid("unary+", lookup("+"));
        
        //Semantic
        // remember this line
		if(!($2->is_error)){
			$$->isInit = $2->isInit;
			string temp = unaryExp("+",$2->type);
			if(!temp.empty()){
				$$->type = temp;
				$$->intVal = $2->intVal;

				//--3AC
				qid q = newtemp(temp);
				$$->tempName = $2->tempName;
				$$->place = q;
				$$->nextlist.clear();
				emit(plus,$2->place, qid("", NULL), q, -1);
			}
			else{
				yyerror("Type inconsistent with operator");
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |'-' UnaryExpression {
        vector<data>v;
        insertAttr(v, NULL, "-", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("UnaryExpression", v);

        
        //--3AC
		// $1->place = ;

        //Semantic
		if(!($2->is_error)){
			$$->isInit = $2->isInit;
			string temp = unaryExp("-",$2->type);
			if(!temp.empty()){
				$$->type = temp;
				$$->intVal = $2->intVal;

				//--3AC
				qid q = newtemp(temp);
				$$->tempName = $2->tempName;
				$$->place = q;
				$$->nextlist.clear();
				emit(qid("unary-", lookup("-")), $2->place, qid("", NULL), q, -1);
			}
			else{
				yyerror("Type inconsistent with operator");
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |UnaryExpressionNotPlusMinus {$$ = $1;}
    ;

PreIncrementExpression
    :INC_OP UnaryExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("PreIncrementExpression", v);

        //Semantic
		if(!$2->is_error && $2->expType!=4){
			$$->isInit = $2->isInit;
			string temp = postfixExpression($2->type,6);
			
			if(!temp.empty()){
				$$->type = temp;
				$$->intVal = $2->intVal +1;

				//--3AC
				qid q = newtemp(temp);
				$$->place = q;
				$$->nextlist.clear();
				emit(qid("++P", NULL), $2->place, qid("", NULL), q, -1);
			}
			else{
				yyerror("Increment not defined for this type");
				$$->is_error = 1;
			}
		}
		else{
			if($2->expType==4){
				yyerror("constant expression cannot be used as lvalue");
			}
			$$->is_error = 1;
		}
    }
    ;

PreDecrementExpression
    :DEC_OP UnaryExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("PreDecrementExpression", v);

        //Semantic
		if(!$2->is_error && $2->expType!=4){
			$$->isInit = $2->isInit;
			string temp = postfixExpression($2->type,7);
			if(!temp.empty()){
				$$->type = temp;
				$$->intVal = $2->intVal -1;

				//--3AC
				qid q = newtemp(temp);
				$$->place = q;
				$$->nextlist.clear();
				emit(qid("--P", NULL), $2->place, qid("", NULL), q, -1);
			}
			else{
				yyerror("Decrement not defined for this type");
			}
		}
		else{
			if($2->expType==4){
				yyerror("constant expression cannot be used as lvalue");
			}
			$$->is_error = 1;
		}
    }
    ;

UnaryExpressionNotPlusMinus
    :PostfixExpression {$$ = $1;}

    |'~' UnaryExpression {
        vector<data>v;
        insertAttr(v, NULL, "~", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("UnaryExpressionNotPlusMinus", v);
        

        //semantic
        // $$->place = ;

        if(!($2->is_error)){
			$$->isInit = $2->isInit;
			string temp = unaryExp("~",$2->type);
			if(!temp.empty()){
				$$->type = temp;
				$$->intVal = ~($2->intVal);

				//--3AC
				qid q = newtemp(temp);
				$$->tempName = $2->tempName;
				$$->place = q;
				$$->nextlist.clear();
				emit(qid("~", lookup("~")), $2->place, qid("", NULL), q, -1);
			}
			else{
				yyerror("Type inconsistent with operator");
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |'!' UnaryExpression {
        vector<data>v;
        insertAttr(v, NULL, "!", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("UnaryExpressionNotPlusMinus", v);

        //semantic
        // $1->place = qid("~", lookup("~"));

        if(! ($2->is_error)){
			$$->isInit = $2->isInit;
			string temp = unaryExp("!",$2->type);
			if(!temp.empty()){
				$$->type = temp;
				$$->intVal = !($2->intVal);

				//--3AC
				qid q = newtemp(temp);
				$$->tempName = $2->tempName;
				$$->place = q;
				$$->nextlist.clear();
				emit(qid("!", lookup("!")), $2->place, qid("", NULL), q, -1);
			}
			else{
				yyerror("Type inconsistent with operator");
				$$->is_error = 1;
			}
		}
		else{
			$$->is_error = 1;
		}
    }
    |CastExpression {$$ = $1;}
    ;

PostfixExpression
    :Primary {$$ = $1;}
    |Name {$$ = $1;}
    |PostIncrementExpression { $$ = $1 ;}
    |PostDecrementExpression { $$ = $1 ;}
    ;

PostIncrementExpression
    :PostfixExpression INC_OP {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
		$$ = makenode("PostIncrementExpression", v);

        //Semantics
		$$->isInit = $1->isInit;
		if(!$1->is_error && $1->expType!=4){
			string temp = postfixExpression($1->type,6);
			if(!temp.empty()){
				$$->type = temp;
				$$->intVal = $1->intVal + 1;

				//--3AC

				qid q = newtemp(temp);
				$$->place = q;
				$$->nextlist.clear();
				emit(qid("++S", NULL), $1->place, qid("", NULL), q, -1);
			}
			else{
				yyerror("Increment not defined for this type");
				$$->is_error = 1;
			}
		}
		else{
			if($1->expType==4){
				yyerror("constant expression cannot be used as lvalue");
			}

			$$->is_error = 1;
		}
    }
    ;

PostDecrementExpression
    :PostfixExpression DEC_OP {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
		$$ = makenode("PostDecrementExpression", v);

        //Semantics
		if(!$1->is_error && $1->expType!=4){
			$$->isInit = $1->isInit;
			string temp = postfixExpression($1->type,7);
			if(!temp.empty()){
				$$->type = temp;
				$$->intVal = $1->intVal - 1;

				//--3AC

				qid q = newtemp(temp);
				$$->place = q;
				$$->nextlist.clear();
				emit(qid("--S", NULL), $1->place, qid("", NULL), q, -1);

			}
			else{
				yyerror("Decrement not defined for this type");
				$$->is_error = 1;
			}
		}
		else{
			if($1->expType==4){
				yyerror("constant expression cannot be used as lvalue");
			}
			$$->is_error = 1;
		}

    }
    ;

CastExpression
    : '(' PrimitiveType ')' UnaryExpression  { // 1
        vector<data>v;
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$4, "", 1);
		$$ = makenode("CastExpression", v);
    }
    ;



G 	
    : Identifier 	{
		$$ = makeleaf($1);
		className = $1;
		classTemp = className ; 
	}
    ;

S 
    : %empty {
		$$ = new treeNode;
		createStructTable();

		if(type != "") {
			yyerror(("cannot combine with previous " + type + " declaration specifier").c_str());
			$$->is_error = 1;
		}
	}
    ;

NEXT_QUAD
	: %empty {
		$$ = code.size();
	}
	;

ChangeTable
	: %empty {
		if(func_flag){
			string str = "Block" +to_string(block_count);
			block_stack.push(block_count);
			block_count++;
			func_flag++;
			makeSymbolTable(str, "",0);
		}
		else func_flag++;
	}
	;

A
	: %empty	{
		type ="";
		func_flag = 0;
		funcArgs.clear();
		createParamList();
		gotolablelist.clear();
		gotolabel.clear();
	}

%%
    
int main(int argc, char* argv[]){

    dotfile=fopen(argv[1],"w");

    if(dotfile == NULL){
		/* print_error(); */
		cout<<"cannot open the dot file AST.dot"<<"\nCompilation terminated\n";
		return -1;
	}

    symTable_init();
	beginAST();
    yyparse();

    /* for(int i=2; i<argc; i++){
        if(!strcmp(argv[i], "-dump-sym-table")) dump_sym_table = 1;
		else if(!strcmp(argv[i], "-dump-tac")) dump_tac = 1;
		else if(!strcmp(argv[i], "-dump-all")) dump_tac = dump_sym_table = 1;
    } */
	setGlobal();
	print3AC();
	endAST();
	printSymbolTable(&globalst, "#Global_Symbol_Table#.csv");
    
    return 0;
}

void yyerror(char const* s){
    cout << "Error: " << s << " in Line no: " << line << endl;
    return;
}

// set type as int and read integer value correctly depending on the base
void set_int_type(int t){
	yylval.num = new constants;
	yylval.num->str = strdup(yytext);
	yylval.num->type = string("int");
	switch(t){
		// 3-> hexadecimal, 2-> octal, 1-> decimal, 0-> char
		case 0 : {
			sscanf(yytext, "%", &(yylval.num->intVal));
			yylval.num->intVal = char_int(yylval.num->str);
			yylval.num->type = "char";
			break;
		}
		case 1 : {
			sscanf(yytext, "%lld", &(yylval.num->intVal));
			break;
		}
		case 2 : {
			sscanf(yytext, "%llo", &(yylval.num->intVal));
			break;
		}
		case 3 : {
			sscanf(yytext, "%llx", &(yylval.num->intVal));
			break;
		}
	}
}

// convert character to an integer value
int char_int(string str){
    if(str[1] == '\\'){
        string s = str.substr(1,2);
        if(s == "\\0") return 0;
        if(s == "\\n") return 10;
        if(s == "\\t") return 9;
    } 
    int val = (int)str[1];
    return (val);
}

// set type as float and read the real value
void set_real_type(){
	yylval.num = new constants ;
	yylval.num->str = strdup(yytext);
	yylval.num->type = string("float");
	sscanf(yytext, "%lf", &(yylval.num->realVal));
}