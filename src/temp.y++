%{
    #include<iostream>
    #include<stdio.h>
    #include "ast.h"
    #include <fstream>
    using namespace std;
    extern char* yytext;
    extern int line;
    extern void yyerror(char const*);
    int yylex (void); /* type of yylex() */
    #define YYDEBUG 1
    #define YYERROR_VERBOSE

    FILE* dotfile;
%}

%union { 
    char* str;
    treeNode* ptr;
    int ind;
}

%token<str> PTR_OP INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP METHOD_REFERENCE ELLIPSIS AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN UNSIGNED_RIGHT UNSIGNED_RIGHT_ASSIGN XOR_ASSIGN OR_ASSIGN

%token<str>integerLiteral stringLiteral nullLiteral characterLiteral textBlock booleanLiteral FloatingPointLiteral Identifier ABSTRACT CONTINUE FOR NEW ASSERT DEFAULT IF PACKAGE SYNCHRONIZED BOOLEAN PRIVATE THIS BREAK DOUBLE THROW BYTE ELSE PUBLIC ENUM INSTANCEOF RETURN TRANSIENT INT SHORT CHAR FINAL INTERFACE STATIC VOID CLASS LONG STRICTFP VOLATILE FLOAT NATIVE SUPER WHILE _ EXPORTS OPENS REQUIRES USES MODULE PERMITS SEALED VAR NON_SEALED PROVIDES TO WITH OPEN RECORD TRANSITIVE YIELD eof

%type<ptr> ModuleDirective2 AdditiveExpression AmbiguousName AndExpression  AnnotationInterfaceBody AnnotationInterfaceDeclaration AnnotationInterfaceElementDeclaration AnnotationInterfaceElementModifier AnnotationInterfaceElementModifiers AnnotationInterfaceMemberDeclarations AnnotationInterfaceMemberDeclaration ArgumentList ArrayAccess ArrayCreationExpression ArrayInitializer ArrayType AssertStatement Assignment AssignmentExpression AssignmentOperator Block BlockStatement BlockStatements BreakStatement CastExpression ClassBody ClassBodyDeclaration ClassDeclaration ClassInstanceCreationExpression ClassLiteral ClassMemberDeclaration ClassModifiers ClassModifier ClassOrInterfaceTypeToInstantiate ClassPermits CompactConstructorDeclaration CompilationUnit ConditionalAndExpression ConditionalExpression ConditionalOrExpression ConstantDeclaration ConstantModifiers ConstantModifier ConstructorBody ConstructorDeclaration ConstructorDeclarator ConstructorModifier ConstructorModifiers ContinueStatement DefaultValue DimExpr DimExprs Dims ElementValue ElementValueArrayInitializer ElementValueList ElementValuePair ElementValuePairList EnumBody EnumConstant EnumConstantList EnumDeclaration EqualityExpression ExclusiveOrExpression ExplicitConstructorInvocation Expression ExpressionStatement FieldAccess FieldDeclaration FieldModifier FloatingPointType ForInit FormalParameter FormalParameterList ForStatement ForStatementNoShortIf ForUpdate Identifiers IfThenElseStatement IfThenElseStatementNoShortIf IfThenStatement InclusiveOrExpression InstanceofExpression IntegralType InterfaceBody InterfaceDeclaration InterfaceMemberDeclaration InterfaceMemberDeclarations InterfaceMethodDeclaration InterfaceMethodModifier InterfaceMethodModifiers InterfaceModifier InterfacePermits LabeledStatement LabeledStatementNoShortIf LambdaBody LambdaExpression LambdaParameter LambdaParameterList LambdaParameters LambdaParameterType LeftHandSide Literal LocalVariableDeclaration LocalVariableType MarkerAnnotation MethodBody MethodDeclaration MethodDeclarator MethodHeader MethodInvocation MethodModifier MethodModifiers MethodReference ModularCompilationUnit ModuleDirective ModuleDirectives ModuleName ModuleNames MultiplicativeExpression NormalAnnotation NormalClassDeclaration NormalInterfaceDeclaration NumericType OrdinaryCompilationUnit PackageDeclaration PackageName PackageOrTypeName Pattern PostDecrementExpression PostfixExpression PostIncrementExpression PreDecrementExpression PreIncrementExpression Primary PrimaryNoNewArray PrimitiveType ReceiverParameter RecordBody RecordBodyDeclaration RecordBodyDeclarations RecordComponent RecordComponentList RecordDeclaration RecordHeader RelationalExpression RequiresModifier RequiresModifiers Result ReturnStatement ShiftExpression SingleElementAnnotation Statement StatementExpression StatementExpressionList StatementNoShortIf StatementWithoutTrailingSubstatement StaticInitializer SynchronizedStatement ThrowStatement TopLevelClassDeclarations  TypeArgumentsOrDiamond TypeNames TypePattern  UnannArrayType UnannClassType UnannPrimitiveType UnannReferenceType UnannType UnaryExpression UnaryExpressionNotPlusMinus UnqualifiedClassInstanceCreationExpression VariableArityParameter VariableArityRecordComponent VariableDeclarator VariableDeclaratorId VariableDeclaratorList VariableInitializer VariableInitializerList  VariableModifiers WhileStatement WhileStatementNoShortIf YieldStatement ModuleDeclaration2 PrimitiveType2 Dims2 ClassPermitsy ClassBodyDeclarations FieldModifiers VariableDeclaratory  ReceiverParametery FormalParameterListy Dimsy Identifiery FormalParameterList2 ExplicitConstructorInvocationy ExplicitConstructorInvocation2 ArgumentListy comay EnumConstantListy ArgumentListyy ClassBodyy EnumBodyDeclarationsy RecordComponentListy  InterfacePermitsy InterfaceModifiers DefaultValuey ElementValuePairListy ElementValuePairList2 ElementValueListy ElementValueList2 VariableInitializerListy VariableInitializerList2 AssertStatement2 BasicForHeader EnhancedForHeader ForInity Expressiony ForUpdatey StatementExpressionList2 Identifieryy Brackets TypeArgumentsOrDiamondy ClassOrInterfaceTypeToInstant ArgumentList2 DimExprs2 LambdaParameterListy LambdaParameterList2 Identifiers2 ConditionalExpression2 ConditionalExpression3 EqualityExpression2 RelationalExpression2 InstanceofExpression2 ShiftExpression2 AdditiveExpression2 MultiplicativeExpressionSym CastExpression2 CommonModifier CommonModifiers FieldOrMethod FieldOrMethod2 ClassMemberDeclaration2 VariableDeclaratorId2
%start CompilationUnit


%%


CompilationUnit
    : OrdinaryCompilationUnit {
        cout << "in compile unit\n";
        vector<data> v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        $$ = makenode("CompilationUnit",v);
    }
    ;
    
OrdinaryCompilationUnit
    : PackageDeclaration TopLevelClassDeclarations {
        vector<data> v;
		insertAttr(v,$1,"",1);
		insertAttr(v,$2,"",1);
		$$ = makenode("Ordinary_Compilation_Unit",v);
    }
    | TopLevelClassDeclarations {
        $$ = $1;
    }
    ;

TopLevelClassDeclarations
    : %empty {$$=NULL;}
    | TopLevelClassDeclarations ClassDeclaration  {
        cout << "TopLevelClassDeclarations\n";
        vector<data> v;
		insertAttr(v,$1,"",1);
		insertAttr(v,$2,"",1);
		$$ = makenode("Top_level_class_or_interface_declarations",v);
    }
    ;

PackageDeclaration
    : PACKAGE TypeName ';' {NumericType
        vector<data> v;
		insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,makeleaf($2),"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,NULL,";",0);
		$$ = makenode("Package_declaration",v);
    }
    ;

//grammar for chapter 4

Literal
    : integerLiteral {cout << "Hello\n"; $$=makeleaf($1);}
    | FloatingPointLiteral {$$=makeleaf($1);}
    | booleanLiteral {$$=makeleaf($1);}
    | characterLiteral {$$=makeleaf($1);}
    | stringLiteral {$$=makeleaf($1);}
    | textBlock {$$=makeleaf($1);}
    | nullLiteral {$$=makeleaf($1);}
    ;

Type
    :PrimitiveType
    ;

PrimitiveType
    : BYTE {$$ = makeleaf($1);}
    | SHORT {$$ = makeleaf($1);}
    | INT {$$ = makeleaf($1);}
    | LONG {$$ = makeleaf($1);}
    | CHAR {$$ = makeleaf($1);}
    | FLOAT {$$ = makeleaf($1);}
    | DOUBLE {$$ = makeleaf($1);}
    | BOOLEAN {$$ = makeleaf($1);}
    ;

ArrayType
    :PrimitiveType Dims{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("Arraytype", v);
    }
    | TypeName Dims
    ;

Dims
    : Dims '[' ']' {
        vector<data> v;
        insertAttr(v, NULL, "[", 0);
        insertAttr(v, NULL, "]", 0);
        insertAttr(v, $3, "", 1);
		$$ = makenode("Dims", v);
    }
    | '[' ']'
    ;


//Grammar for Names
TypeName
    :TypeName '.' Identifier
    |Identifier
    ;


// class

ClassDeclaration
    :NormalClassDeclaration
    ;

NormalClassDeclaration
    : Modifier CLASS Identifier ClassPermits ClassBody
    | CLASS Identifier ClassPermits ClassBody
    ;

Modifier
    :PUBLIC
    |PRIVATE
    ;

ClassPermits
    :PERMITS TypeNameCOMMA
    ;

TypeNameCOMMA
    :TypeNameCOMMA ',' TypeName
    |TypeName
    ;

ClassBody
    :'{' ClassBodyDeclaration '}'
    ;

ClassBodyDeclarations
    :ClassBodyDeclarations ClassBodyDeclaration
    |%empty
    ;

ClassBodyDeclaration
    :ClassMemberDeclaration
    |InstanceInitializer
    |StaticInitializer
    |ConstructorDeclaration
    ;

ClassMemberDeclaration
    :FieldDeclaration
    |MethodDeclaration
    |ClassDeclaration
    |';'
    ;

FieldDeclaration
    :FieldModifiers Type VariableDeclaratorList ';'
    |Type VariableDeclaratorList ';'
    ;

FieldModifiers
    :FieldModifier
    |FieldModifiers FieldModifier
    ;

FieldModifier
    :PUBLIC
    |PRIVATE
    |STATIC
    |FINAL
    ;

VariableDeclaratorList
    :VariableDeclaratorList ',' VariableDeclarator
    |VariableDeclarator
    ;

VariableDeclarator
    :VariableDeclaratorId
    |VariableDeclaratorId '=' VariableInitializer
    ;

VariableDeclaratorId
    :Identifier 
    |Identifier Dims
    ;

VariableInitializer
    :Expression
    |ArrayInitializer
    ;

MethodDeclaration
    :MethodModifiers MethodHeader MethodBody
    |MethodHeader MethodBody
    ;

MethodModifiers
    :MethodModifier MethodModifier
    |MethodModifier
    ;
MethodModifier
    :PUBLIC
    |PRIVATE
    |STATIC
    ;

MethodHeader
    :Result MethodDeclarator
    ;
Result
    :Type
    |VOID
    ;
MethodDeclarator
    :Identifier '(' ReceiverParameterCOMMA FormalParameterListy ')' 
    |Identifier '(' ReceiverParameterCOMMA FormalParameterListy ')' Dims
    ;

ReceiverParameter
    :Type THIS
    |Type Identifier '.' THIS
    ;
ReceiverParameterCOMMA
    :ReceiverParameter ','
    |%empty
    ;
FormalParameterListy
    :%empty
    |FormalParameterList
    ;
FormalParameterList
    :FormalParameter
    |FormalParameterList ',' FormalParameter
    ;

FormalParameter
    :Type VariableDeclaratorId
    |VariableModifier Type VariableDeclaratorId
    |VariableArityParameter
    ;

VariableArityParameter
    :Type ELLIPSIS Identifier
    |VariableModifier Type ELLIPSIS Identifier
    ;

VariableModifier
    :FINAL
    ;

ExceptionTypeList
    :ExceptionTypeList ',' ExceptionType
    |ExceptionType
    ;

ExceptionType
    :TypeName
;

MethodBody
    :Block
    |';'
    ;

InstanceInitializer
    :Block
    ;
StaticInitializer
    :STATIC Block
    ;

ConstructorDeclaration
    :Modifier ConstructorDeclarator ConstructorBody
    |ConstructorDeclarator ConstructorBody
    ;

ConstructorDeclarator
    :SimpleTypeName '(' ReceiverParameterCOMMA FormalParameterListy ')'
    ;

SimpleTypeName
    :Identifier
    ;

ConstructorBody
    :'{' '}'
    |'{' BlockStatements '}'
    |'{' ExplicitConstructorInvocation BlockStatements '}'
    |'{' ExplicitConstructorInvocation '}'
    ;

ExplicitConstructorInvocation
    :THIS '(' ArgumentListy ')' ';'
    |SUPER '(' ArgumentListy ')' ';'
    |TypeName '.' SUPER '(' ArgumentListy ')' ';'
    |Primary '.' SUPER '(' ArgumentListy ')' ';'
    ;

ArgumentListy
    :%empty
    |ArgumentList
    ;

//10. Arrays

ArrayInitializer
    :'{' VariableInitializerListy Comay '}'{
        vector<data>v;
        insertAttr(v, NULL, "{", 0);
        insertAttr(v, $2, "", 1);
        insertAttr(v, $3, "", 1);
        insertAttr(v, NULL, "}", 0);
		$$ = makenode("ArrayInitializer", v);
    }
;
Comay
    :%empty
    |','
    ;
VariableInitializerListy
    : %empty {$$=NULL;}
    | VariableInitializerList {$$=$1;}
    ;
    
VariableInitializerList
    :VariableInitializerList ',' VariableInitializer {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("VariableInitializerList", v);
    }
    |VariableInitializer
    ;

//14. Productions from (blocks, statements and patterns)

Block
    :'{' BlockStatements '}'{
        vector<data>v;
        insertAttr(v, NULL, "{", 0);
        insertAttr(v, $2, "", 1);
        insertAttr(v, NULL, "}", 0);
		$$ = makenode("Block", v);
    }
    ;

BlockStatements
    : %empty {$$=NULL;}
    | BlockStatements BlockStatement{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("BlockStatements", v);
    }
    ;

BlockStatement
    : ClassDeclaration {$$=$1;}
    | LocalVariableDeclaration ';' {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("BlockStatement", v);
    }
    | Statement {$$=$1;}
    ;


LocalVariableDeclaration
    :VariableModifiers LocalVariableType FieldDeclaration{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
        insertAttr(v, $3, "", 1);
		$$ = makenode("LocalVariableDeclaration", v);
    }
    ;

LocalVariableType
    : Type{$$=$1;}
    | VAR{$$ = makeleaf($1);}
    ;

Statement
    :StatementWithoutTrailingSubstatement{$$=$1;}
    |LabeledStatement{$$=$1;}
    |IfThenStatement{$$=$1;}
    |IfThenElseStatement{$$=$1;}
    |WhileStatement{$$=$1;}
    |ForStatement{$$=$1;}
    ;

StatementNoShortIf
    :StatementWithoutTrailingSubstatement{$$=$1;}
    |LabeledStatementNoShortIf{$$=$1;}
    |IfThenElseStatementNoShortIf{$$=$1;}
    |WhileStatementNoShortIf{$$=$1;}
    |ForStatementNoShortIf{$$=$1;}
    ;

StatementWithoutTrailingSubstatement
    :Block{$$=$1;}
    |';'{$$=makeleaf(";");}
    |ExpressionStatement{$$=$1;}
    |AssertStatement{$$=$1;}
    |BreakStatement{$$=$1;}
    |ContinueStatement{$$=$1;}
    |ReturnStatement{$$=$1;}
    |SynchronizedStatement{$$=$1;}
    |ThrowStatement{$$=$1;}
    |YieldStatement{$$=$1;}
    ;   

LabeledStatement
    :Identifier ':' Statement{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, ":", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("LabeledStatement", v);
    }
;

LabeledStatementNoShortIf
    :Identifier ':' StatementNoShortIf{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, ":", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("LabeledStatementNoShortIf", v);
    }
;

ExpressionStatement
    :StatementExpression ';'{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ExpressionStatement", v);
    }
;

StatementExpression
    :Assignment{$$=$1;}
    |PreIncrementExpression{$$=$1;}
    |PreDecrementExpression{$$=$1;}
    |PostIncrementExpression{$$=$1;}
    |PostDecrementExpression{$$=$1;}
    |MethodInvocation{$$=$1;}
    |ClassInstanceCreationExpression{$$=$1;}
;

IfThenStatement
    :IF '(' Expression ')' Statement{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$5, "", 1);
		$$ = makenode("IfThenStatement", v);
    }
;

IfThenElseStatement
    :IF '(' Expression ')' StatementNoShortIf ELSE Statement{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$5, "", 1);
        insertAttr(v,makeleaf($6), "", 1);
        insertAttr(v,$7, "", 1);
		$$ = makenode("IfThenElseStatement", v);
    }
;

IfThenElseStatementNoShortIf
    :IF '(' Expression ')' StatementNoShortIf ELSE StatementNoShortIf{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$5, "", 1);
        insertAttr(v,makeleaf($6), "", 1);
        insertAttr(v,$7, "", 1);
		$$ = makenode("IfThenElseStatementNoShortIf", v);
    }
;

AssertStatement
    :ASSERT Expression AssertStatement2 ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v,NULL, ";", 0);
		$$ = makenode("AssertStatement", v);
    }
;

AssertStatement2
    :%empty {$$=NULL;}
    |':' Expression{
        vector<data>v;
        insertAttr(v, NULL, ":", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("AssertStatement2", v);
    }
;

WhileStatement
    : WHILE '(' Expression ')' Statement{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$5, "", 1);
		$$ = makenode("WhileStatement", v);
    }
;

WhileStatementNoShortIf
    :WHILE '(' Expression ')' StatementNoShortIf{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$5, "", 1);
		$$ = makenode("WhileStatementNoShortIf", v);
    }
;

ForStatement
    : BasicForHeader Statement{
        vector<data> v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("For_statement", v);
    }
    | EnhancedForHeader Statement{
        vector<data> v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("For_statement", v);
    }
;

ForStatementNoShortIf
    : BasicForHeader StatementNoShortIf{
        vector<data> v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("For_statement_no_short_if", v);
    }
    | EnhancedForHeader StatementNoShortIf{
        vector<data> v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("For_statement_no_short_if", v);
    }
;

BasicForHeader
    : FOR '(' ForInity ';' Expressiony ';' ForUpdatey ')' {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ";", 0);
        insertAttr(v,$5, "", 1);
        insertAttr(v, NULL, ";", 0);
        insertAttr(v,$7, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("Basic_For_Header", v);
    }

EnhancedForHeader
    : FOR '(' LocalVariableDeclaration ':' Expression ')' {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ";", 0);
        insertAttr(v,$5, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("Enhanced_For_Header", v);
    }

ForInity
    : %empty {$$=NULL;}
    | ForInit {$$=$1;}
    ;

Expressiony
    : %empty {$$=NULL;}
    | Expression {$$=$1;}
    ;

ForUpdatey
    : %empty {$$=NULL;}
    | ForUpdate {$$=$1;}
    ;

ForInit
    :StatementExpressionList{$$=$1;}
    |LocalVariableDeclaration{$$=$1;}
;

ForUpdate
    :StatementExpressionList{$$=$1;}
;

StatementExpressionList
    :StatementExpression StatementExpressionList2{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("StatementExpressionList", v);
    }
;

StatementExpressionList2
    :%empty {$$=NULL;}
    |',' StatementExpression StatementExpressionList2{
        vector<data>v;
        insertAttr(v, NULL, ",", 0);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3,"",1);
		$$ = makenode("StatementExpressionList2", v);
    }
;

BreakStatement
    :BREAK Identifieryy ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("BreakStatement", v);
    }
;

Identifieryy
    :%empty {$$=NULL;}
    |Identifier{$$=makeleaf($1);}
;

YieldStatement
    :YIELD Expression ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("YieldStatement", v);
    }
;

ContinueStatement
    :CONTINUE Identifieryy ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ContinueStatement", v);
    }
;

ReturnStatement
    :RETURN Expressiony ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ReturnStatement", v);
    }
;

ThrowStatement
    :THROW Expression ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ThrowStatement", v);
    }
;

SynchronizedStatement
    :SYNCHRONIZED '(' Expression ')' Block{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$5, "", 1);
		$$ = makenode("SynchronizedStatement", v);
    }
;


Pattern
    :TypePattern {$$=$1;}
;

TypePattern
    :LocalVariableDeclaration {$$=$1;}
;

//Grammar for Expressions

Primary
    :PrimaryNoNewArray{$$=$1;}
    |ArrayCreationExpression{$$ = $1;}
    ;
PrimaryNoNewArray
    :Literal{$$=$1;}
    |ClassLiteral{$$=$1;}
    |THIS {$$ = makeleaf($1);}
    |TypeName '.' THIS{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v, makeleaf($3), "", 1);
		$$ = makenode("PrimaryNoNewArray", v);
    }
    |'(' Expression ')'{
        vector<data>v;
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("PrimaryNoNewArray", v);
    }
    |ClassInstanceCreationExpression{$$=$1;}
    |FieldAccess {$$=$1 ;}
    |ArrayAccess {$$ = $1;}
    |MethodInvocation {$$ = $1;}
    |MethodReference {$$ = $1;}
    ;
ClassLiteral
    :TypeName Brackets '.' CLASS{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v, makeleaf($4), "", 1);
		$$ = makenode("ClassLiteral", v);
    }
    |NumericType Brackets '.' CLASS{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v, makeleaf($4), "", 1);
		$$ = makenode("ClassLiteral", v);
    }
    |BOOLEAN Brackets '.' CLASS{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,makeleaf($4), "", 1);
		$$ = makenode("ClassLiteral", v);
    }
    |VOID '.' CLASS{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,makeleaf($3), "", 1);  
		$$ = makenode("ClassLiteral", v);
    }
    ;

Brackets
    :%empty {$$=NULL;}
    |'[' ']' Brackets{
        vector<data>v;
        insertAttr(v, NULL, "[", 0);
        insertAttr(v, NULL, "]", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("Brackets", v);
    }
    ;

ClassInstanceCreationExpression
    :UnqualifiedClassInstanceCreationExpression {$$ = $1;}
    |TypeName '.' UnqualifiedClassInstanceCreationExpression{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ClassInstanceCreationExpression", v);
    }
    |Primary '.' UnqualifiedClassInstanceCreationExpression{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ClassInstanceCreationExpression", v);
    }
    ;
UnqualifiedClassInstanceCreationExpression
    :NEW ClassOrInterfaceTypeToInstantiate '(' ArgumentListy ')' ClassBodyy {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, $2, "", 1);
        insertAttr(v, NULL, "(", 1);
        insertAttr(v, $4, "", 1);
        insertAttr(v, NULL, ")", 1);
        insertAttr(v, $6, "", 1);
		$$ = makenode("UnqualifiedClassInstanceCreationExpression", v);
    }
    ;

ClassOrInterfaceTypeToInstantiate
    : Identifier ClassOrInterfaceTypeToInstant TypeArgumentsOrDiamondy {
        vector<data>v;
        insertAttr(v,makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ClassOrInterfaceTypeToInstantiate", v);
    }
    ;

TypeArgumentsOrDiamondy
    : %empty {$$=NULL;}
    | TypeArgumentsOrDiamond {$$=$1;}
    ;

ClassOrInterfaceTypeToInstant
    : %empty {$$=NULL;}
    | '.' Identifier ClassOrInterfaceTypeToInstant  {
        vector<data>v;
        insertAttr(v,NULL,".",0);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ClassOrInterfaceTypeToInstant", v);
    }
    ;

TypeArgumentsOrDiamond
    :'<''>'{
        vector<data>v;
        insertAttr(v, NULL, "<", 0);
        insertAttr(v, NULL, ">", 0);
		$$ = makenode("TypeArgumentsOrDiamond", v);
    }
    ;

FieldAccess
    :Primary '.' Identifier{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v, makeleaf($3), "", 1);
		$$ = makenode("FieldAccess", v);
    }
    |SUPER '.' Identifier{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,makeleaf($3), "", 1);
		$$ = makenode("FieldAccess", v);
    }
    |TypeName '.' SUPER '.' Identifier{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v, makeleaf($3), "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,makeleaf($5), "", 1);
		$$ = makenode("FieldAccess", v);
    }
    ;

ArrayAccess
    :TypeName '[' Expression ']' {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "[", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, "]", 0);
		$$ = makenode("ArrayAccess", v);
    }
    |PrimaryNoNewArray '[' Expression ']'{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "[", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, "]", 0);
		$$ = makenode("ArrayAccess", v);
    }

    ;

MethodInvocation
    :Identifier ArgumentListyy {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("MethodInvocation", v);
    }
    |TypeName '.' Identifier ArgumentListyy {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,makeleaf($3), "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("MethodInvocation", v);
    }
    |TypeName '.' Identifier ArgumentListyy {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,makeleaf($3), "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("MethodInvocation", v);
    }
    |Primary '.' Identifier ArgumentListyy {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,makeleaf($3), "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("MethodInvocation", v);
    }
    |SUPER '.' Identifier ArgumentListyy {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,makeleaf($3), "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("MethodInvocation", v);
    }
    |TypeName '.' SUPER '.' Identifier ArgumentListyy {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,makeleaf($3), "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v, makeleaf($5), ".", 0);
        insertAttr(v,$6, "", 1);
		$$ = makenode("MethodInvocation", v);
    }
;

ArgumentList
    :ArgumentList Expression {
        vector<data> v;
        insertAttr(v, $1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("ArgumentList",v);
    }
    |Expression
    ;

MethodReference
    :TypeName METHOD_REFERENCE Identifier {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v, makeleaf($3), "", 1);
		$$ = makenode("MethodReference", v);
    }
    |Primary METHOD_REFERENCE Identifier {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v, makeleaf($3), "", 1);
		$$ = makenode("MethodReference", v);
    }
    |SUPER METHOD_REFERENCE Identifier {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v, makeleaf($3), "", 1);
		$$ = makenode("MethodReference", v);
    }
    |TypeName '.' SUPER METHOD_REFERENCE Identifier {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v, makeleaf($3), "", 1);
        insertAttr(v, makeleaf($4), "", 1);
        insertAttr(v, makeleaf($5), "", 1);
		$$ = makenode("MethodReference", v);
    }
    |ArrayType METHOD_REFERENCE NEW {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v,makeleaf($3), "", 1);
		$$ = makenode("MethodReference", v);
    }
    ;

ArrayCreationExpression
    :NEW PrimitiveType DimExprs Dimsy {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("ArrayCreationExpression", v);
    }
    |NEW PrimitiveType Dims ArrayInitializer {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("ArrayCreationExpression", v);
    }
    ;

DimExprs
    :DimExpr DimExprs2 {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("DimExprs", v);
    }
    ;

DimExprs2
    :%empty {$$=NULL;}
    |DimExpr DimExprs2 {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("DimExprs", v);
    }
    ;

DimExpr
    :'[' Expression ']' {
        vector<data>v;
        insertAttr(v, NULL, "[", 0);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, "]", 0);
		$$ = makenode("DimExpr", v);
    }
    ;

Expression
    :AssignmentExpression {$$ = $1;}
    ;

AssignmentExpression
    :ConditionalExpression {cout << "cond_expr\n"; $$ = $1;}
    |Assignment {$$ = $1;}
    ;

Assignment
    :LeftHandSide AssignmentOperator Expression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("Assignment", v);
    }
    ;

LeftHandSide
    :TypeName {$$ = $1;}
    |FieldAccess{$$=$1;}
    |ArrayAccess{$$=$1;}
    ;

AssignmentOperator
    :'='{$$ = makeleaf("=");}
    |MUL_ASSIGN {$$ = makeleaf($1);}
    |DIV_ASSIGN {$$ = makeleaf($1);}
    |MOD_ASSIGN{$$ = makeleaf($1);}
    |ADD_ASSIGN{$$ = makeleaf($1);}
    |SUB_ASSIGN{$$ = makeleaf($1);}
    |LEFT_ASSIGN{$$ = makeleaf($1);}
    |RIGHT_ASSIGN{$$ = makeleaf($1);}
    |UNSIGNED_RIGHT_ASSIGN{$$ = makeleaf($1);}
    |AND_ASSIGN{$$ = makeleaf($1);}
    |XOR_ASSIGN{$$ = makeleaf($1);}
    |OR_ASSIGN{$$ = makeleaf($1);}
;

ConditionalExpression
    :ConditionalOrExpression ConditionalExpression2{
        cout << "conditionalexpression\n";
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
        cout << "hiiiii\n";
		$$ = makenode("ConditionalExpression", v);
        // cout << "conditionalexpression2\n";
    }
    ;

ConditionalExpression2
    :%empty {$$=NULL;}
    |'?' Expression ':' ConditionalExpression3 {
        vector<data>v;
        insertAttr(v, NULL, "?", 0);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ":", 0);
        insertAttr(v,$4, "", 1);
		$$ = makenode("ConditionalExpression2", v);
    }
    ;

ConditionalExpression3
    :ConditionalExpression {$$ = $1 ;}
    |LambdaExpression { $$ = $1 ; }
    ;

ConditionalOrExpression
    :ConditionalAndExpression { $$ = $1 ; }
    |ConditionalOrExpression OR_OP ConditionalAndExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ConditionalOrExpression", v);
    }
    ;
ConditionalAndExpression
    :InclusiveOrExpression { $$ = $1 ;}
    |ConditionalAndExpression AND_OP InclusiveOrExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ConditionalAndExpression", v);
    }
    ;

InclusiveOrExpression
    :ExclusiveOrExpression {$$ = $1;}
    |InclusiveOrExpression '|' ExclusiveOrExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "|", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("InclusiveOrExpression", v);
    }
    ;
ExclusiveOrExpression
    :AndExpression {$$ = $1;}
    |ExclusiveOrExpression '^' AndExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "^", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ExclusiveOrExpression", v);
    }
    ;

AndExpression
    :EqualityExpression {$$ = $1;}
    |AndExpression '&' EqualityExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "&", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("AndExpression", v);
    }
    ;

EqualityExpression
    :RelationalExpression {$$ = $1 ;}
    |EqualityExpression EqualityExpression2 {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("EqualityExpression", v);
    }
    ;

EqualityExpression2 
    :EQ_OP RelationalExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("EqualityExpression2 ", v);
    }
    |NE_OP RelationalExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2 , "", 1);
		$$ = makenode("EqualityExpression2", v);
    }
    ;

RelationalExpression
    :ShiftExpression {$$ = $1;}
    |RelationalExpression RelationalExpression2 {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("RelationalExpression", v);
    }
    ;

RelationalExpression2 
    :'<' ShiftExpression {
        vector<data>v;
        insertAttr(v, NULL, "<", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("RelationalExpression2", v);
    }
    |'>' ShiftExpression {
        vector<data>v;
        insertAttr(v, NULL, ">", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("RelationalExpression2", v);
    }
    |LE_OP ShiftExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("RelationalExpression2", v);
    }
    |GE_OP ShiftExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("RelationalExpression2", v);
    }
    ;

ShiftExpression
    :AdditiveExpression {$$= $1;}
    |ShiftExpression ShiftExpression2 {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("ShiftExpression", v);
    }
    ;

ShiftExpression2
    :LEFT_OP AdditiveExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("ShiftExpression2", v);
    }
    |RIGHT_OP AdditiveExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("ShiftExpression2", v);
    }
    |UNSIGNED_RIGHT AdditiveExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("ShiftExpression2", v);
    }
    ;

AdditiveExpression
    :MultiplicativeExpression {$$ = $1;}
    |AdditiveExpression AdditiveExpression2 {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("AdditiveExpression", v);
    }
    ;

AdditiveExpression2
    :'+' MultiplicativeExpression {
        vector<data>v;
        insertAttr(v, NULL, "+", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("AdditiveExpression2", v);
    }
    |'-' MultiplicativeExpression {
        vector<data>v;
        insertAttr(v, NULL, "-", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("AdditiveExpression2", v);
    }
    ;

MultiplicativeExpression
    :UnaryExpression {$$ = $1;}
    |MultiplicativeExpression MultiplicativeExpressionSym UnaryExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3,"",1);
		$$ = makenode("MultiplicativeExpression", v);
    }
    ;

MultiplicativeExpressionSym
    : '*' {$$=makeleaf("*");}
    | '/' {$$=makeleaf("/");}
    | '%' {$$=makeleaf("%");}
    ;

UnaryExpression
    :PreIncrementExpression {$$ = $1;}
    |PreDecrementExpression {$$ = $1;}
    |'+' UnaryExpression {
        vector<data>v;
        insertAttr(v, NULL, "+", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("UnaryExpression", v);
    }
    |'-' UnaryExpression {
        vector<data>v;
        insertAttr(v, NULL, "-", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("UnaryExpression", v);
    }
    |UnaryExpressionNotPlusMinus {$$ = $1;}
    ;

PreIncrementExpression
    :INC_OP UnaryExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("PreIncrementExpression", v);
    }
    ;

PreDecrementExpression
    :DEC_OP UnaryExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("PreDecrementExpression", v);
    }
    ;

UnaryExpressionNotPlusMinus
    :PostfixExpression {$$ = $1;}
    |'~' UnaryExpression {
        vector<data>v;
        insertAttr(v, NULL, "~", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("UnaryExpressionNotPlusMinus", v);
    }
    |'!' UnaryExpression {
        vector<data>v;
        insertAttr(v, NULL, "!", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("UnaryExpressionNotPlusMinus", v);
    }
    |CastExpression {$$ = $1;}
    ;

PostfixExpression
    :Primary {cout<<"postfix\n"; $$ = $1;}
    |TypeName {$$ = $1;}
    |PostIncrementExpression { $$ = $1 ;}
    |PostDecrementExpression { $$ = $1 ;}
    ;

PostIncrementExpression
    :PostfixExpression INC_OP {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
		$$ = makenode("PostIncrementExpression", v);
    }
    ;

PostDecrementExpression
    :PostfixExpression DEC_OP {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
		$$ = makenode("PostDecrementExpression", v);
    }
    ;

CastExpression
    : '(' CastExpression2 {
        vector<data>v;
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("CastExpression", v);
    }

CastExpression2
    :PrimitiveType ')' UnaryExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("CastExpression2", v);
    }
    ;

%%



int main(){
    dotfile = fopen("AST.dot", "w");
	
	if(dotfile == NULL){
		cout<<"cannot open the dot file AST.dot"<<"\nCompilation terminated\n";
		return -1;
	}

	beginAST();
    yyparse();
	endAST();

    return 0;
}

void yyerror(char const* s){
    cout << "Error: " << s << " in Line no: " << line << endl;
    return;
}