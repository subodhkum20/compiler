%{
    #include<iostream>
    #include<stdio.h>
    #include "ast.h"
    #include <fstream>
    using namespace std;
    extern char* yytext;
    extern int line;
    int yylex (void); /* type of yylex() */
    int yyerror(char const*);
    #define YYDEBUG 1
    #define YYERROR_VERBOSE

    FILE* dotfile;
%}

%union { 
    char* str;
    treeNode* ptr;
    int ind;
}

%token<str> PTR_OP INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP METHOD_REFERENCE ELLIPSIS AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN UNSIGNED_RIGHT UNSIGNED_RIGHT_ASSIGN XOR_ASSIGN OR_ASSIGN

%token<str>integerLiteral stringLiteral nullLiteral characterLiteral textBlock booleanLiteral FloatingPointLiteral Identifier ABSTRACT CONTINUE FOR NEW ASSERT DEFAULT IF PACKAGE SYNCHRONIZED BOOLEAN PRIVATE THIS BREAK DOUBLE IMPLEMENTS THROW BYTE ELSE PUBLIC THROWS ENUM INSTANCEOF RETURN TRANSIENT EXTENDS INT SHORT CHAR FINAL INTERFACE STATIC VOID CLASS FINALLY LONG STRICTFP VOLATILE FLOAT NATIVE SUPER WHILE _ EXPORTS OPENS REQUIRES USES MODULE PERMITS SEALED VAR NON_SEALED PROVIDES TO WITH OPEN RECORD TRANSITIVE YIELD EOF

%type<ptr> ModuleDirective2 AdditionalBounds AdditiveExpression AmbiguousName AndExpression Annotation Annotations AnnotationInterfaceBody AnnotationInterfaceDeclaration AnnotationInterfaceElementDeclaration AnnotationInterfaceElementModifier AnnotationInterfaceElementModifiers AnnotationInterfaceMemberDeclarations AnnotationInterfaceMemberDeclaration ArgumentList ArrayAccess ArrayCreationExpression ArrayInitializer ArrayType AssertStatement Assignment AssignmentExpression AssignmentOperator Block BlockStatement BlockStatements BreakStatement CastExpression ClassBody ClassBodyDeclaration ClassDeclaration ClassExtends ClassImplements ClassInstanceCreationExpression ClassLiteral ClassMemberDeclaration ClassModifiers ClassModifier ClassOrInterfaceType ClassOrInterfaceTypeToInstantiate ClassPermits ClassType CompactConstructorDeclaration CompilationUnit ConditionalAndExpression ConditionalExpression ConditionalOrExpression ConstantDeclaration ConstantExpression ConstantModifiers ConstantModifier ConstructorBody ConstructorDeclaration ConstructorDeclarator ConstructorModifier ConstructorModifiers ContinueStatement DefaultValue DimExpr DimExprs Dims ElementValue ElementValueArrayInitializer ElementValueList ElementValuePair ElementValuePairList EnumBody EnumConstant EnumConstantList EnumDeclaration EqualityExpression ExceptionType ExceptionTypeList ExclusiveOrExpression ExplicitConstructorInvocation Expression ExpressionName ExpressionStatement FieldAccess FieldDeclaration FieldModifier Finally FloatingPointType ForInit FormalParameter FormalParameterList ForStatement ForStatementNoShortIf ForUpdate Identifiers IfThenElseStatement IfThenElseStatementNoShortIf IfThenStatement InclusiveOrExpression InstanceofExpression IntegralType InterfaceBody InterfaceDeclaration InterfaceExtends InterfaceMemberDeclaration InterfaceMemberDeclarations InterfaceMethodDeclaration InterfaceMethodModifier InterfaceMethodModifiers InterfaceModifier InterfacePermits InterfaceTypeList LabeledStatement LabeledStatementNoShortIf LambdaBody LambdaExpression LambdaParameter LambdaParameterList LambdaParameters LambdaParameterType LeftHandSide Literal LocalClassOrInterfaceDeclaration LocalVariableDeclaration LocalVariableType MarkerAnnotation MethodBody MethodDeclaration MethodDeclarator MethodHeader MethodInvocation MethodModifier MethodModifiers MethodReference ModularCompilationUnit ModuleDirective ModuleDirectives ModuleName ModuleNames MultiplicativeExpression NormalAnnotation NormalClassDeclaration NormalInterfaceDeclaration NumericType OrdinaryCompilationUnit PackageDeclaration PackageName PackageOrTypeName Pattern PostDecrementExpression PostfixExpression PostIncrementExpression PreDecrementExpression PreIncrementExpression Primary PrimaryNoNewArray PrimitiveType ReceiverParameter RecordBody RecordBodyDeclaration RecordBodyDeclarations RecordComponent RecordComponentList RecordDeclaration RecordHeader ReferenceType RelationalExpression RequiresModifier RequiresModifiers Result ReturnStatement ShiftExpression SingleElementAnnotation Statement StatementExpression StatementExpressionList StatementNoShortIf StatementWithoutTrailingSubstatement StaticInitializer SynchronizedStatement Throws ThrowStatement TopLevelClassOrInterfaceDeclaration TopLevelClassOrInterfaceDeclarations Type TypeArgument TypeArguments TypeArgumentList TypeArgumentsOrDiamond TypeBound TypeName TypeNames TypeParameter TypeParameters TypeParameterList TypePattern TypeVariable UnannArrayType UnannClassOrInterfaceType UnannClassType UnannInterfaceType UnannPrimitiveType UnannReferenceType UnannType UnannTypeVariable UnaryExpression UnaryExpressionNotPlusMinus UnqualifiedClassInstanceCreationExpression VariableArityParameter VariableArityRecordComponent VariableDeclarator VariableDeclaratorId VariableDeclaratorList VariableInitializer VariableInitializerList VariableModifier VariableModifiers WhileStatement WhileStatementNoShortIf Wildcard WildcardBounds YieldStatement ModuleDeclaration2 PrimitiveType2 ClassType2 Dims2 TypeParameter2 TypeBound2 TypeArgumentList2 Wildcard2 TypeParametersy ClassExtendsy ClassImplementsy ClassPermitsy ClassBodyDeclarations FieldModifiers VariableDeclaratory TypeArgumentsy Throwsy ReceiverParametery FormalParameterListy Dimsy Identifiery FormalParameterList2 ExplicitConstructorInvocationy BlockStatementsy ExplicitConstructorInvocation2 ArgumentListy comay EnumConstantListy ArgumentListyy ClassBodyy EnumBodyDeclarationsy RecordComponentListy InterfaceExtendsy InterfacePermitsy InterfaceModifiers DefaultValuey ElementValuePairListy ElementValuePairList2 ElementValueListy ElementValueList2 VariableInitializerListy VariableInitializerList2 AssertStatement2 BasicForHeader EnhancedForHeader ForInity Expressiony ForUpdatey StatementExpressionList2 Identifieryy Brackets TypeArgumentsOrDiamondy ClassOrInterfaceTypeToInstant ArgumentList2 DimExprs2 LambdaParameterListy LambdaParameterList2 Identifiers2 ConditionalExpression2 ConditionalExpression3 EqualityExpression2 RelationalExpression2 InstanceofExpression2 ShiftExpression2 AdditiveExpression2 MultiplicativeExpressionSym CastExpression2 CastExpression3
%start CompilationUnit


%%

//grammar for chapter 4

Literal
    : integerLiteral {$$=makeleaf($1);}
    | FloatingPointLiteral {$$=makeleaf($1);}
    | booleanLiteral {$$=makeleaf($1);}
    | characterLiteral {$$=makeleaf($1);}
    | stringLiteral {$$=makeleaf($1);}
    | textBlock {$$=makeleaf($1);}
    | nullLiteral {$$=makeleaf($1);}
    ;

Type
    : PrimitiveType {$$ = $1;}
    | ReferenceType {$$ = $1;}
    ;

PrimitiveType
    : Annotations PrimitiveType2 {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("Primtive_type", v);
    }
    ;

PrimitiveType2
    : NumericType {$$ = $1;}
    | BOOLEAN {$$ = makeleaf($1);}
    ;

Annotations
    : %empty
    | Annotation Annotations{
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("Annotations", v);
    }
    ;

NumericType
    : IntegralType {
        $$ = $1;
    }
    | FloatingPointType {
        $$ = $1 ;
    }
    ;

IntegralType   
    : BYTE {$$ = makeleaf($1);}
    | SHORT {$$ = makeleaf($1);}
    | INT {$$ = makeleaf($1);}
    | LONG {$$ = makeleaf($1);}
    | CHAR {$$ = makeleaf($1);}
    ;

FloatingPointType
    : FLOAT {$$ = makeleaf($1);}
    | DOUBLE {$$ = makeleaf($1);}
    ;
ReferenceType
    : ClassOrInterfaceType {$$ = $1;}
    | TypeVariable {$$ = $1;}
    | ArrayType {$$ = $1;}
    ;

ClassOrInterfaceType
    : ClassType{$$ = $1}
    ;

ClassType
    : Annotations Identifier ClassType2{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, makeleaf($2) , "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("Class_type", v);
    }
    | PackageName '.' Annotations Identifier ClassType2{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3 , "" , 1);
        insertAttr(v,makeleaf($4), "" , 1);
        insertAttr(v, $5, "", 1);
		$$ = makenode("Class_type", v);
    }
    | ClassOrInterfaceType '.' Annotations Identifier ClassType2{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "" , 1);
        insertAttr(v,makeleaf($4), "" , 1);
        insertAttr(v, $5, "", 1);
		$$ = makenode("Class_type", v);
    }
    ;

ClassType2
    : %empty 
    | TypeArguments {$$ = $1;}
    ;

TypeVariable
    :Annotations Identifier{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v,makeleaf($2), "" , 1);
		$$ = makenode("TypeVariable", v);
    }
    ;

ArrayType
    :PrimitiveType Dims{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("Arraytype", v);
    }
    |ClassOrInterfaceType Dims{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("Array type", v);
    }
    |TypeVariable Dims{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("Array type", v);
    }
    ;

Dims
    : Annotations '[' ']' Dims2 {
        vector<data> v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, "[", 0);
        insertAttr(v, NULL, "]", 0);
        insertAttr(v, $4, "", 1);
		$$ = makenode("Dims", v);
    }
    ;

Dims2
    : %empty
    | Annotations '[' ']' Dims2{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, "[", 0);
        insertAttr(v, NULL, "]", 0);
        insertAttr(v, $4, "", 1);
		$$ = makenode("Dims", v);
    }
    ;
    
TypeParameter
    :Annotations Identifier TypeParameter2{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v, $3, "", 1);
		$$ = makenode("Typeparameter", v);
    }
    ;

TypeParameter2
    : %empty 
    | TypeBound {$$=$1;}
    ;

TypeBound
    :EXTENDS TypeBound2{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("Type_bound", v);
    }
    ;

TypeBound2
    :TypeVariable{
        $$ = $1;
    }
    |ClassOrInterfaceType AdditionalBounds{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("Typebound", v);
    }
    ;

AdditionalBounds
    :%empty 
    |'&' ClassType AdditionalBounds{
        vector<data>v;
        insertAttr(v, NULL, "&", 0);
        insertAttr(v, $2, "", 1);
        insertAttr(v, $3, "", 1);
		$$ = makenode("Additional_bound", v);
    }
    ;

TypeArguments
    :'<' TypeArgumentList '>'{
        vector<data>v;
        insertAttr(v, NULL, "<", 0);
        insertAttr(v, $2, "", 1);
        insertAttr(v, NULL, ">", 0);
		$$ = makenode("TypeArguments", v);
    }
    ;

TypeArgumentList
    : TypeArgument TypeArgumentList2{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("TypeArgumentList", v);
    }
    ;

TypeArgumentList2 
    : %empty 
    | ',' TypeArgument TypeArgumentList{
        vector<data>v;
        insertAttr(v, NULL, ",", 0);
        insertAttr(v, $2, "", 1);
		$$ = makenode("TypeArgumentList", v);
    }
    ;

TypeArgument
    : ReferenceType{
        $$ = $1;
    }
    | Wildcard{
        $$ = $1;
    }
    ;

Wildcard
    : Annotations '?' Wildcard2{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, "?", 0);
        insertAttr(v, $3, "", 1);
		$$ = makenode("WildCard", v);
    }
    ;

Wildcard2
    :%empty 
    |WildcardBounds{
        $$ = $1;
    }
    ;

WildcardBounds
    : EXTENDS ReferenceType {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("WildcardBounds", v);
    }
    | SUPER ReferenceType {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("WildcardBounds", v);
    }
    ;

//Grammar for Names
ModuleName
    : Identifier {$$=makeleaf($1);}
    | ModuleName '.' Identifier {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v,NULL,".",0);
        insertAttr(v, makeleaf($3), "", 1);
		$$ = makenode("Module_name", v);
    }
    ;

PackageName
    : Identifier {$$=makeleaf($1);}
    | PackageName '.' Identifier {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v,NULL,".",0);
        insertAttr(v, makeleaf($3), "", 1);
		$$ = makenode("Package_name", v);
    }
    ;

TypeName
    : Identifier {$$=makeleaf($1);}
    | PackageOrTypeName '.' Identifier {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v,NULL,".",0);
        insertAttr(v, makeleaf($3), "", 1);
		$$ = makenode("type_name", v);
    }
    ;

ExpressionName
    : Identifier {$$ =makeleaf($1);}
    | AmbiguousName '.' Identifier {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v,NULL,".",0);
        insertAttr(v, makeleaf($3), "", 1);
		$$ = makenode("Expression_name", v);
    }
    ;

PackageOrTypeName
    : Identifier {$$=makeleaf($1);}
    | PackageOrTypeName '.' Identifier {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v,NULL,".",0);
        insertAttr(v, makeleaf($3), "", 1);
		$$ = makenode("package_or_tpye_name", v);
    }
    ;

AmbiguousName
    : Identifier {$$=makeleaf($1);}
    | AmbiguousName '.' Identifier {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v,NULL,".",0);
        insertAttr(v, makeleaf($3), "", 1);
		$$ = makenode("ambiguous_name", v);
    }
    ;

//start
CompilationUnit
    : OrdinaryCompilationUnit EOF {
        vector<data> v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        $$ = makenode("CompilationUnit",v);
    }
    | ModularCompilationUnit EOF {
        vector<data> v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        $$ = makenode("Compilation_Unit",v);
    }
    ;
    
OrdinaryCompilationUnit
    : PackageDeclaration TopLevelClassOrInterfaceDeclarations {
        vector<data> v;
		insertAttr(v,$1,"",1);
		insertAttr(v,$2,"",1);
		$$ = makenode("Ordinary_Compilation_Unit",v);
    }
    | TopLevelClassOrInterfaceDeclarations {
        $$ = $1;
    }
    ;

TopLevelClassOrInterfaceDeclarations
    : %empty
    | TopLevelClassOrInterfaceDeclaration TopLevelClassOrInterfaceDeclarations {
        vector<data> v;
		insertAttr(v,$1,"",1);
		insertAttr(v,$2,"",1);
		$$ = makenode("Top_level_class_or_interface_declarations",v);
    }
    ;

TopLevelClassOrInterfaceDeclaration
    : ClassDeclaration InterfaceDeclaration ';' {
        vector<data> v;
		insertAttr(v,$1,"",1);
		insertAttr(v,$2,"",1);
        insertAttr(v,NULL,";",0);
		$$ = makenode("Top_level_class_or_interface_declaration",v);
    }
    ;

PackageDeclaration
    : Annotations PACKAGE Identifier Identifiers ';' {
        vector<data> v;
		insertAttr(v,$1,"",1);
		insertAttr(v,makeleaf($2),"",1);
        insertAttr(v,makeleaf($3),"",1);
        insertAttr(v,$4,"",1);
        insertAttr(v,NULL,";",0);
		$$ = makenode("Package_declaration",v);
    }
    ;

Identifiers
    : %empty
    | '.' Identifier Identifiers {
        vector<data> v;
        insertAttr(v,NULL,".",0);
        insertAttr(v,makeleaf($2),"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Identifiers",v);
    }
    ;

ModularCompilationUnit
    : Annotations ModuleDeclaration2 {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Modular_Compilation_Unit",v);
    }
    ;

ModuleDeclaration2
    : OPEN MODULE Identifier Identifiers '{' ModuleDirectives '}' {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,makeleaf($2),"",1);
        insertAttr(v,makeleaf($3),"",1);
        insertAttr(v,$4,"",1);
        insertAttr(v,NULL,"{",0);
        insertAttr(v,$6,"",1);
        insertAttr(v,NULL,"}",0);
        $$ = makenode("Module_declaration",v);
    }
    | MODULE Identifier Identifiers '{' ModuleDirectives '}' {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,makeleaf($2),"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,NULL,"{",0);
        insertAttr(v,$5,"",1);
        insertAttr(v,NULL,"}",0);
        $$ = makenode("Module_declaration",v);
    }
    ;

ModuleDirectives
    : %empty
    | ModuleDirective ModuleDirectives {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Module_Directives",v);
    }
    ;

ModuleDirective
    : REQUIRES RequiresModifiers ModuleName ';' {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,NULL,";",0);
        $$ = makenode("Module_Directive",v);
    }
    | EXPORTS PackageName ModuleDirective2 {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Module_Directive",v);
    }
    | OPENS PackageName ModuleDirective2 {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Module_Directive",v);
    }
    | USES TypeName ';' {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,NULL,";",0);
        $$ = makenode("Module_Directive",v);
    }
    | PROVIDES TypeName WITH TypeName TypeNames ';' {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,makeleaf($3),"",1);
        insertAttr(v,$4,"",1);
        insertAttr(v,$5,"",1);
        insertAttr(v,NULL,";",0);
        $$ = makenode("Module_Directive",v);
    }
    ;

ModuleDirective2
    : TO ModuleName ModuleNames ';' {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,NULL,";",0);
        $$ = makenode("Module_Directive2",v);
    }
    | ';'
    ;

RequiresModifiers
    : %empty 
    | RequiresModifier RequiresModifiers {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Require_modifiers",v);
    }
    ;

ModuleNames
    : %empty
    | ',' ModuleName ModuleNames {
        vector<data> v;
        insertAttr(v,NULL,",",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Module_Names",v);
    }
    ;

TypeNames
    : %empty
    | ',' TypeName TypeNames {
        vector<data> v;
        insertAttr(v,NULL,",",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Module_Names",v);
    }
    ;

RequiresModifier
    : TRANSITIVE {
        $$ = makeleaf($1);
    }
    | STATIC {
        $$ = makeleaf($1);
    }
    ;


//grammar from classes

ClassDeclaration
    : NormalClassDeclaration {
        $$ = $1;
    }
    | EnumDeclaration {
        $$ = $1;
    }
    | RecordDeclaration {
        $$ = $1;
    }
    ;

NormalClassDeclaration
    : ClassModifiers CLASS Identifier TypeParametersy ClassExtendsy ClassImplementsy ClassPermitsy ClassBody {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,makeleaf($2),"",1);
        insertAttr(v,makeleaf($3),"",1);
        insertAttr(v,$4,"",1);
        insertAttr(v,$5,"",1);
        insertAttr(v,$6,"",1);
        insertAttr(v,$7,"",1);
        insertAttr(v,$8,"",1);
        $$ = makenode("Normal_Class_Declaration",v);
    }
    ;

TypeParametersy
    : %empty
    | TypeParameters {
        $$ = $1;
    }
    ;

ClassExtendsy
    : %empty
    | ClassExtends {
        $$ = $1;
    }
    ;

ClassImplementsy
    : %empty
    | ClassImplements {
        $$ = $1;
    }
    ;

ClassPermitsy
    : %empty
    | ClassPermits {
        $$ = $1;
    }
    ;

ClassModifiers
    : %empty
    | ClassModifier ClassModifiers {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Class_modifier",v);
    }
    ;

ClassModifier
    : Annotation {$$=$1;} 
    | PUBLIC {$$ = makeleaf($1);}
    | PRIVATE {$$ = makeleaf($1);}
    | ABSTRACT {$$ = makeleaf($1);}
    | STATIC {$$ = makeleaf($1);}
    | FINAL {$$ = makeleaf($1);}
    | SEALED {$$ = makeleaf($1);}
    | NON_SEALED {$$ = makeleaf($1);}
    | STRICTFP {$$ = makeleaf($1);}
    ;

TypeParameters
    : '<' TypeParameter TypeParameterList '>' {
        vector<data> v;
        insertAttr(v,NULL,"<",0);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,NULL,">",0);
        $$ = makenode("Type_Parameters",v);
    }
    ;

TypeParameterList
    :  %empty
    |  ',' TypeParameter TypeParameterList {
        vector<data> v;
        insertAttr(v,NULL,",",0);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Type_ParameterList",v);
    }
    ;

ClassExtends
    : EXTENDS ClassType {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Class_Extends",v);
    }
    ;

ClassImplements
    : IMPLEMENTS ClassType InterfaceTypeList {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Class_Implements",v);
    }
    ;

InterfaceTypeList
    : %empty 
    | ',' ClassType InterfaceTypeList {
        vector<data> v;
        insertAttr(v,NULL,",",0);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Interface_Type_List",v);
    }
    ;

ClassPermits
    : PERMITS TypeName TypeNames {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Class_Permits",v);
    }
    ;

ClassBody
    : '{'ClassBodyDeclarations'}' {
        vector<data> v;
        insertAttr(v,NULL,"{",0);
        insertAttr(v,$2,"",1);
        insertAttr(v,NULL,"}",0);
        $$ = makenode("Class_Body",v);
    }
    ;

ClassBodyDeclarations
    : %empty
    | ClassBodyDeclaration ClassBodyDeclarations {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Class_Body_Declarations",v);
    }
    ;

ClassBodyDeclaration
    : ClassMemberDeclaration {$$=$1;}
    | Block {$$=$1;}
    | StaticInitializer {$$=$1;}
    | ConstructorDeclaration {$$=$1;}
    ;

ClassMemberDeclaration
    : FieldDeclaration {$$=$1;}
    | MethodDeclaration {$$=$1;}
    | ClassDeclaration {$$=$1;}
    | InterfaceDeclaration {$$=$1;}
    |';'
    ;

FieldDeclaration
    : FieldModifiers UnannType VariableDeclaratorList ';' {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,NULL,";",0);
        $$ = makenode("Field_Declaration",v);
    }
    ;

FieldModifiers
    : %empty
    | FieldModifier FieldModifiers {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Field_Modifiers",v);
    }
    ;

FieldModifier
    : Annotation {$$=$1;}
    | PUBLIC {$$=makeleaf($1);}
    | PRIVATE {$$=makeleaf($1);}
    | STATIC {$$=makeleaf($1);}
    | FINAL {$$=makeleaf($1);}
    | TRANSIENT {$$=makeleaf($1);}
    | VOLATILE {$$=makeleaf($1);}
    ;

VariableDeclaratorList
    : VariableDeclarator {$$=$1;}
    | VariableDeclarator ',' VariableDeclaratorList {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,NULL,",",0);
        insertAttr(v,$3,"",1);
        $$ = makenode("Variable_Declarator_List",v);
    }
    ;

VariableDeclarator
    : VariableDeclaratorId VariableDeclaratory {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Variable_Declarator",v);
    }
    ;

VariableDeclaratory
    : %empty
    | '=' VariableInitializer {
        vector<data> v;
        insertAttr(v,NULL,"=",0);
        insertAttr(v,$2,"",1);
        $$ = makenode("Variable_Declarator",v);
    }

VariableDeclaratorId
    : Identifier Dimsy {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Variable_Declarator_Id",v);
    }
    ;

VariableInitializer
    : Expression {$$=$1;}
    | ArrayInitializer {$$=$1;}
    ;

UnannType
    : UnannPrimitiveType {$$=$1;}
    | UnannReferenceType {$$=$1;}
    ;

UnannPrimitiveType
    : NumericType {$$=$1;}
    | BOOLEAN {$$=makeleaf($1);}
    ;

UnannReferenceType
    : UnannClassOrInterfaceType {$$=$1;}
    | UnannTypeVariable {$$=$1;}
    | UnannArrayType {$$=$1;}
    ;

UnannClassOrInterfaceType
    : UnannClassType {$$=$1;}
    | UnannInterfaceType {$$=$1;}
    ;

UnannClassType
    : Identifier TypeArgumentsy {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Unn_Class_Type",v);
    }
    | PackageName '.' Annotations Identifier TypeArgumentsy {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,NULL,".",0);
        insertAttr(v,$3,"",1);
        insertAttr(v,makeleaf($4),"",1);
        insertAttr(v,$5,"",1);
        $$ = makenode("Unn_Class_Type",v);
    }
    | UnannClassOrInterfaceType '.' Annotations Identifier TypeArgumentsy {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,NULL,".",0);
        insertAttr(v,$3,"",1);
        insertAttr(v,makeleaf($4),"",1);
        insertAttr(v,$5,"",1);
        $$ = makenode("Unn_Class_Type",v);
    }
    ;

TypeArgumentsy
    : %empty
    | TypeArguments {$$=$1;}
    ;

UnannInterfaceType
    : UnannClassType {$$=$1;}
    ;

UnannTypeVariable
    : Identifier {$$=makeleaf($1);}
    ;

UnannArrayType
    : UnannPrimitiveType Dims {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Unn_Array_Type",v);
    }
    | UnannClassOrInterfaceType Dims {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Unn_Array_Type",v);
    }
    | UnannTypeVariable Dims {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Unn_Array_Type",v);
    }
    ;

MethodDeclaration
    : MethodModifiers MethodHeader MethodBody {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Method_declaration",v);
    }
    ;

MethodModifiers
    : %empty
    | MethodModifier MethodModifiers {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Method_modifiers",v);
    }
    ;

MethodModifier
    : Annotation {$$=$1;}
    | PUBLIC {$$=makeleaf($1);}
    | PRIVATE {$$=makeleaf($1);}
    | ABSTRACT {$$=makeleaf($1);}
    | STATIC {$$=makeleaf($1);}
    | FINAL {$$=makeleaf($1);}
    | SYNCHRONIZED {$$=makeleaf($1);}
    | NATIVE {$$=makeleaf($1);}
    | STRICTFP {$$=makeleaf($1);}
    ;

MethodHeader
    : Result MethodDeclarator Throwsy {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Method_header",v);
    }
    | TypeParameters Annotations Result MethodDeclarator Throwsy {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,$4,"",1);
        insertAttr(v,$5,"",1);
        $$ = makenode("Methdod_header",v);
    }
    ;

Throwsy
    : %empty
    | Throws {$$=$1;}
    ;

Result
    : UnannType {$$=$1;}
    | VOID {$$=makeleaf($1);}
    ;

MethodDeclarator
    : Identifier '(' ReceiverParametery FormalParameterListy ')' Dimsy {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,NULL,"(",0);
        insertAttr(v,$3,"",1);
        insertAttr(v,$4,"",1);
        insertAttr(v,NULL,")",0);
        insertAttr(v,$6,"",1);
        $$ = makenode("Methdod_declarator",v);
    }
    ;

ReceiverParametery
    : ReceiverParameter ',' {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,NULL,",",0);
        $$ = makenode("ReceiverParameter",v);
    }
    | %empty
    ;

FormalParameterListy
    : %empty
    | FormalParameterList {$$=$1;}
    ;

Dimsy
    : %empty
    | Dims {$$=$1;}
    ;

ReceiverParameter
    : Annotations UnannType Identifiery THIS {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,makeleaf($4),"",1);
        $$ = makenode("Identifiery",v);
    }
    ;

Identifiery
    : Identifier '.' {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,NULL,".",0);
        $$ = makenode("Identifiery",v);
    }
    | %empty
    ;

FormalParameterList
    : FormalParameter FormalParameterList2 {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Formal_Parameter_list",v);
    }
    ;

FormalParameterList2
    : %empty
    | ',' FormalParameter FormalParameterList2 {
        vector<data> v;
        insertAttr(v,NULL,",",0);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Formal_Parameter_list",v);
    }
    ;

FormalParameter
    : VariableModifiers UnannType VariableDeclaratorId {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("Formal_Parameter",v);
    }
    | VariableArityParameter {$$=$1;}
    ;

VariableArityParameter
    : VariableModifiers UnannType Annotations ELLIPSIS Identifier {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,makeleaf($4),"",1);
        insertAttr(v,makeleaf($5),"",1);
        $$ = makenode("Variable_arity_Parameter",v);
    }
    ;

VariableModifiers
    : %empty
    | VariableModifier VariableModifiers {
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Variable_modifier",v);
    }
    ;

VariableModifier
    : Annotation {$$=$1;}
    | FINAL {$$=makeleaf($1);}
    ;

Throws
    : THROWS ExceptionType ExceptionTypeList {
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Throws",v);
    }
    ;

ExceptionTypeList
    : %empty
    | ',' ExceptionType ExceptionTypeList {
        vector<data> v;
        insertAttr(v,NULL,",",0);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("ExceptionTypeList",v);
    }
    ;

ExceptionType
    : ClassType {$$=$1;}
    | TypeVariable {$$=$1;}
    ;

MethodBody
    : Block {$$=$1;}
    | ';' {$$=makeleaf(";")}
    ;

StaticInitializer
    : STATIC Block {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("StaticInitilizer",v);
    }
    ;

ConstructorDeclaration
    : ConstructorModifiers ConstructorDeclarator Throwsy ConstructorBody {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,$4,"",1);
        $$ = makenode("Constructor_declaration",v);
    }
    ;

ConstructorModifiers
    : %empty
    | ConstructorModifier ConstructorModifiers {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Constructor_modifier",v);
    }
    ;

ConstructorModifier
    : Annotation {$$=$1;}
    | PUBLIC {$$=makeleaf($1);}
    | PRIVATE {$$=makeleaf($1);}
    ;

ConstructorDeclarator
    : TypeParametersy Identifier '(' ReceiverParametery FormalParameterListy ')' {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,makeleaf($2),"",1);
        insertAttr(v,NULL,"(",0);
        insertAttr(v,$4,"",1);
        insertAttr(v,$5,"",1);
        insertAttr(v,NULL,")",0);
        $$ = makenode("Constructor_declarator",v);
    }
    ;

ConstructorBody
    : '{' ExplicitConstructorInvocationy BlockStatementsy '}' {
        vector<data> v;
        insertAttr(v,NULL,"{",0);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,NULL,"}",0);
        $$ = makenode("Constructor_body",v);
    }
    ;

ExplicitConstructorInvocationy
    : %empty
    | ExplicitConstructorInvocation {$$=$1;}
    ;

BlockStatementsy
    : %empty
    | BlockStatements {$$=$1;}
    ;

ExplicitConstructorInvocation
    : TypeArgumentsy ExplicitConstructorInvocation2 {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("ExplicitConstructorInvocation",v);
    }
    | ExpressionName '.' TypeArgumentsy SUPER '(' ArgumentListy ')' ';' {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,NULL,".",0);
        insertAttr(v,$3,"",1);
        insertAttr(v,makeleaf($4),"",1);
        insertAttr(v,NULL,"(",0);
        insertAttr(v,$6,"",1);
        insertAttr(v,NULL,")",0);
        insertAttr(v,NULL,";",0);
        $$ = makenode("ExplicitConstructorInvocation",v);
    }
    | Primary '.' TypeArgumentsy SUPER '(' ArgumentListy ')' ';' {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,NULL,".",0);
        insertAttr(v,$3,"",1);
        insertAttr(v,makeleaf($4),"",1);
        insertAttr(v,NULL,"(",0);
        insertAttr(v,$6,"",1);
        insertAttr(v,NULL,")",0);
        insertAttr(v,NULL,";",0);
        $$ = makenode("ExplicitConstructorInvocation",v);
    }
    ;

ExplicitConstructorInvocation2
    : THIS '(' ArgumentListy ')' ';' {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,NULL,"(",0);
        insertAttr(v,$3,"",1);
        insertAttr(v,NULL,")",0);
        insertAttr(v,NULL,";",0);
        $$ = makenode("ExplicitConstructorInvocation",v);
    }
    | SUPER '(' ArgumentListy ')' ';' {
        vector<data> v;
        insertAttr(v,makeleaf($1),"",1);
        insertAttr(v,NULL,"(",0);
        insertAttr(v,$3,"",1);
        insertAttr(v,NULL,")",0);
        insertAttr(v,NULL,";",0);
        $$ = makenode("ExplicitConstructorInvocation",v);
    }
    ;

ArgumentListy
    : %empty
    | ArgumentList {$$=$1;}
    ;

EnumDeclaration
    : ClassModifiers ENUM Identifier ClassImplementsy EnumBody {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,makeleaf($2),"",1);
        insertAttr(v,makeleaf($3),"",1);
        insertAttr(v,$4,"",1);
        insertAttr(v,$5,"",1);
        $$ = makenode("Enum_declaration",v);
    }
    ;

EnumBody
    : '{' EnumConstantListy comay EnumBodyDeclarationsy '}' {
        vector<data> v;
        insertAttr(v,NULL,"{",0);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,$4,"",1);
        insertAttr(v,NULL,"}",0);
        $$ = makenode("Enum_body",v);
    }
    ;

comay
    : %empty
    | ',' {$$=makeleaf(",")};
    ;

EnumConstantListy
    : %empty
    | EnumConstant EnumConstantList {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Enum_constant_list",v);
    }
    ;

EnumConstantList
    : %empty
    | ',' EnumConstantList {
        vector<data> v;
        insertAttr(v,NULL,",",0);
        insertAttr(v,$2,"",1);
        $$ = makenode("Enum_constant_list",v);
    }
    ;

EnumConstant
    : Annotations Identifier ArgumentListyy ClassBodyy {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,makeleaf($2),"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,$4,"",1);
        $$ = makenode("Enum_constant",v);
    }
    ;

ArgumentListyy
    : %empty 
    | '(' ArgumentListy ')' {
        vector<data> v;
        insertAttr(v,NULL,"(",0);
        insertAttr(v,$2,"",1);
        insertAttr(v,NULL,")",0);
        $$ = makenode("Argumentlist",v);
    }
    ;   

ClassBodyy
    : %empty
    | ClassBody {$$=$1;}
    ;

EnumBodyDeclarationsy
    : ';' ClassBodyDeclarations {
        vector<data> v;
        insertAttr(v,NULL,";",0);
        insertAttr(v,$2,"",1);
        $$ = makenode("EnumBodyDeclarations",v);
    }
    | %empty
    ;

RecordDeclaration
    : ClassModifiers RECORD Identifier TypeParametersy RecordHeader ClassImplementsy RecordBody {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,makeleaf($2),"",1);
        insertAttr(v,makeleaf($3),"",1);
        insertAttr(v,$4,"",1);
        insertAttr(v,$5,"",1);
        insertAttr(v,$6,"",1);
        insertAttr(v,$7,"",1);
        $$ = makenode("Record_declaration",v);
    }
    ;

RecordHeader
    : '(' RecordComponentListy ')' {
        vector<data> v;
        insertAttr(v,NULL,"(",0);
        insertAttr(v,$2,"",1);
        insertAttr(v,NULL,")",0);
        $$ = makenode("Record_header",v);
    }
    ;

RecordComponentListy
    : %empty
    | RecordComponent RecordComponentList {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("RecordComponentList",v);
    }
    ;

RecordComponentList
    : %empty
    | ',' RecordComponentList {
        vector<data> v;
        insertAttr(v,NULL,",",0);
        insertAttr(v,$2,"",1);
        $$ = makenode("Record_Component_List",v);
    }
    ;

RecordComponent
    : Annotations UnannType Identifier {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,makeleaf($3),"",1);
        $$ = makenode("RecordComponent",v);
    }
    | VariableArityRecordComponent {$$=$1;}
    ;

VariableArityRecordComponent
    : Annotations UnannType Annotations ELLIPSIS Identifier {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        insertAttr(v,$3,"",1);
        insertAttr(v,makeleaf($4),"",1);
        insertAttr(v,makeleaf($5),"",1);
        $$ = makenode("Variable_Arity_RecordComponent",v);
    }
    ;

RecordBody
    : '{' RecordBodyDeclarations '}' {
        vector<data> v;
        insertAttr(v,NULL,"{",0);
        insertAttr(v,$2,"",1);
        insertAttr(v,NULL,"}",0);
        $$ = makenode("Record_body",v);
    }
    ;

RecordBodyDeclarations
    : %empty
    | RecordBodyDeclaration RecordBodyDeclarations {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("Record_body_declarations",v);
    }
    ;

RecordBodyDeclaration
    : ClassBodyDeclaration {$$=$1;}
    | CompactConstructorDeclaration {$$=$1;}
    ;

CompactConstructorDeclaration
    : ConstructorModifiers Identifier ConstructorBody {
        vector<data> v;
        insertAttr(v,$1,"",1);
        insertAttr(v,makeleaf($2),"",1);
        insertAttr(v,$3,"",1);
        $$ = makenode("compact_body",v);
    }
    ;


//14. grammar for Interfaces -----------------------------------

InterfaceDeclaration
    :NormalInterfaceDeclaration{$$=$1;}
    |AnnotationInterfaceDeclaration{$$=$1;}
    ;

NormalInterfaceDeclaration
    :InterfaceModifiers INTERFACE Identifier TypeParametersy InterfaceExtendsy InterfacePermitsy InterfaceBody {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v, makeleaf($3), "", 1);
        insertAttr(v, $4, "", 1);
        insertAttr(v, $5, "", 1);
        insertAttr(v, $6, "", 1);
        insertAttr(v, $7, "", 1);
		$$ = makenode("NormalInterfaceDeclaration", v);   
}
;

InterfaceExtendsy
    : %empty
    | InterfaceExtends {$$=$1;}
    ;

InterfacePermitsy
    : %empty
    | InterfacePermits {$$=$1;}
    ;

InterfaceModifiers
    :%empty 
    |InterfaceModifier InterfaceModifiers{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("InterfaceModifiers", v);
    }
    ;

InterfaceModifier
    : Annotation{$$=$1;}
    | PUBLIC{$$=makeleaf($1);} 
    | PRIVATE{$$=makeleaf($1);}
    | ABSTRACT {$$=makeleaf($1);}
    | STATIC{$$=makeleaf($1);} 
    | SEALED{$$=makeleaf($1);}
    | NON_SEALED{$$=makeleaf($1);}
    | STRICTFP{$$=makeleaf($1);}
    ;

InterfaceExtends
    :EXTENDS InterfaceTypeList{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("InterfaceExtends", v);  
    }
    ;

InterfacePermits
    :PERMITS TypeName TypeNames{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, $2, "", 1);
        insertAttr(v, $3, "", 1);
		$$ = makenode("InterfacePermits", v);  
    }
;

InterfaceBody
    :'{'InterfaceMemberDeclarations'}'{
        vector<data>v;
        insertAttr(v, NULL, "{", 0);
        insertAttr(v, $2, "", 1);
        insertAttr(v, NULL, "}", 0);
		$$ = makenode("InterfaceBody", v);  
    }
    ;

InterfaceMemberDeclarations
    :%empty 
    |InterfaceMemberDeclaration InterfaceMemberDeclarations{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("InterfaceMemberDeclaration", v);  
    }
    ;

InterfaceMemberDeclaration
    :ConstantDeclaration{$$=$1;}
    |InterfaceMethodDeclaration{$$=$1;}
    |ClassDeclaration{$$ = $1 ;}
    |InterfaceDeclaration {$$ = $1 ;}
    |';' {$$ = makeleaf(";");}
    ;

ConstantDeclaration
    :ConstantModifiers UnannType VariableDeclaratorList ';'{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
        insertAttr(v, $3, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ConstantDeclaration", v);  
    }
    ;

ConstantModifiers
    :%empty 
    |ConstantModifier ConstantModifiers{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("ConstantModifiers", v);  
    }
    ;

ConstantModifier
    :Annotation{$$=$1;}
    |PUBLIC{$$ = makeleaf($1);}
    |STATIC{$$ = makeleaf($1);}
    |FINAL{$$ = makeleaf($1);}
    ;

InterfaceMethodDeclaration
    :%empty
    |InterfaceMethodModifiers MethodHeader MethodBody{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
        insertAttr(v, $3, "", 1);
		$$ = makenode("InterfaceMethodDeclaration", v);  
    }
    ;

InterfaceMethodModifiers
    :%empty
    |InterfaceMethodModifier InterfaceMethodModifiers{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("InterfaceMethod", v);  
    }
    ;
InterfaceMethodModifier
    :STRICTFP{$$=makeleaf($1);}
    |Annotation{$$ = $1;}
    |PUBLIC{$$=makeleaf($1);}
    |PRIVATE{$$=makeleaf($1);}
    |ABSTRACT{$$=makeleaf($1);}
    |STATIC{$$=makeleaf($1);}
    |DEFAULT{$$=makeleaf($1);}
    ;

AnnotationInterfaceDeclaration
    :InterfaceModifiers '@' INTERFACE Identifier AnnotationInterfaceBody{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, "@", 0);
        insertAttr(v, makeleaf($3), "", 1);
        insertAttr(v, makeleaf($4), "", 1);
        insertAttr(v, $5, "", 1);
		$$ = makenode("AnnotationInterfaceDeclaration", v); 
    }
    ;
AnnotationInterfaceBody
    :'{' AnnotationInterfaceMemberDeclarations '}'{
        vector<data>v;
        insertAttr(v, NULL, "{", 0);
        insertAttr(v, $2, "", 1);
        insertAttr(v, NULL, "}", 0);
		$$ = makenode("AnnotationInterfaceBody", v); 
    }
    ;
AnnotationInterfaceMemberDeclarations
    :
    |AnnotationInterfaceMemberDeclaration AnnotationInterfaceMemberDeclarations{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("AnnotationInterMemberDeclarations", v); 
    }
;
AnnotationInterfaceMemberDeclaration
    :AnnotationInterfaceElementDeclaration{$$=$1;}
    |ConstantDeclaration{$$=$1;}
    |ClassDeclaration{$$=$1;}
    |InterfaceDeclaration{$$=$1;}
    |';'{$$ = makeleaf(";");}
    ;
AnnotationInterfaceElementDeclaration
    :AnnotationInterfaceElementModifiers UnannType Identifier '(' ')' Dimsy DefaultValuey ';' {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
        insertAttr(v, makeleaf($3), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v, $6, "", 1);
        insertAttr(v, $7, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("AnnotationInterfaceBody", v); 
    }
    ;

DefaultValuey
    : %empty
    | DefaultValue {$$=$1;}
    ;

AnnotationInterfaceElementModifiers
    :%empty
    |AnnotationInterfaceElementModifier AnnotationInterfaceElementModifiers{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("AnnotationInterfaceElementModifiers", v);
    }
    ;

AnnotationInterfaceElementModifier
    :Annotation{$$=$1;}
    |PUBLIC{$$ = makeleaf($1);}
    |ABSTRACT{$$ = makeleaf($1);}
    ;

DefaultValue
    :DEFAULT ElementValue{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("DefaultValue", v);
    }
    ;

Annotation
    :NormalAnnotation{$$=$1;}
    |MarkerAnnotation{$$=$1;}
    |SingleElementAnnotation{$$=$1;}
    ;

NormalAnnotation
    :'@' TypeName '(' ElementValuePairListy ')' {
        vector<data>v;
        insertAttr(v, NULL, "@", 0);
        insertAttr(v, $2, "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v, $4, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("NormalAnnotation", v);
    }
    ;

ElementValuePairListy
    : %empty
    | ElementValuePairList {$$=$1;}
    ;

ElementValuePairList
    :ElementValuePair ElementValuePairList2{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("ElementValuePairList", v);
    }
    ;

ElementValuePairList2
    :%empty 
    |',' ElementValuePair ElementValuePairList2{
        vector<data>v;
        insertAttr(v, NULL, ",", 0);
        insertAttr(v, $2, "", 1);
        insertAttr(v, $3, "", 1);
		$$ = makenode("ElementValuePairList2", v);
    }
    ;


ElementValuePair
    :Identifier '=' ElementValue{
        vector<data>v;
        insertAttr(v,makeleaf($1) , "", 1);
        insertAttr(v, NULL, "=", 0);
        insertAttr(v, $3, "", 1);
		$$ = makenode("ElementValuePair", v);
    }
    ;

ElementValue
    :ConditionalExpression{$$=$1;}
    |ElementValueArrayInitializer{$$=$1;}
    |Annotation{$$=$1;}
    ;

ElementValueArrayInitializer
    :'{' ElementValueListy comay '}' {
        vector<data>v;
        insertAttr(v, NULL, "{", 0);
        insertAttr(v, $2, "", 1);
        insertAttr(v, $3, "", 1);
        insertAttr(v, NULL, "}", 0);
		$$ = makenode("ElementValueArrayInitializer", v);
    }
    ;

ElementValueListy
    : %empty 
    | ElementValueList {$$=$1;}
    ;

ElementValueList
    :ElementValue ElementValueList2{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("ElementValueList", v);
    }
    ;

ElementValueList2
    :%empty 
    |',' ElementValue ElementValueList2{
        vector<data>v;
        insertAttr(v, NULL, ",", 0);
        insertAttr(v, $2, "", 1);
        insertAttr(v, $3, "", 1);
		$$ = makenode("ElementValueList", v);
    }
    ;


MarkerAnnotation
    :'@' TypeName{
        Vector<data>v;
        insertAttr(v, NULL, "@", 0);
        insertAttr(v, $2, "", 1);
		$$ = makenode("MarkerAnnotation", v);
    }
    ;
SingleElementAnnotation
    :'@' TypeName '(' ElementValue ')'{
        vector<data>v;
        insertAttr(v, NULL, "@", 0);
        insertAttr(v, $2, "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v, $4, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("SingleElementAnnotation", v);
    }
    ;


//10. Arrays

ArrayInitializer
    :'{' VariableInitializerListy comay '}'{
        vector<data>v;
        insertAttr(v, NULL, "{", 0);
        insertAttr(v, $2, "", 1);
        insertAttr(v, $3, "", 1);
        insertAttr(v, NULL, "}", 0);
		$$ = makenode("ArrayInitializer", v);
    }
;

VariableInitializerListy
    : %empty
    | VariableInitializerList {$$=$1;}
    ;
    
VariableInitializerList
    :VariableInitializer VariableInitializerList2{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("VariableInitializerList", v);
    }
    ;

VariableInitializerList2
    :%empty
    |',' VariableInitializer VariableInitializerList2{
        vector<data>v;
        insertAttr(v, NULL, ",", 0);
        insertAttr(v, $2, "", 1);
        insertAttr(v,$3,"",1);
		$$ = makenode("VariableInitializerList", v);
    }
    ;

//14. Productions from (blocks, statements and patterns)

Block
    :%empty
    |'{' BlockStatementsy '}'{
        vector<data>v;
        insertAttr(v, NULL, "{", 0);
        insertAttr(v, $2, "", 1);
        insertAttr(v, NULL, "}", 0);
		$$ = makenode("Block", v);
    }
    ;

BlockStatements
    : BlockStatement {$$=$1;}
    | BlockStatement BlockStatements{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
		$$ = makenode("BlockStatements", v);
    }
    ;

BlockStatement
    : LocalClassOrInterfaceDeclaration {$$=$1;}
    | LocalVariableDeclaration ';' {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("BlockStatement", v);
    }
    | Statement {$$=$1;}
    ;

LocalClassOrInterfaceDeclaration
    : ClassDeclaration{$$=$1;}
    | NormalInterfaceDeclaration{$$=$1;}
    ;

LocalVariableDeclaration
    :VariableModifiers LocalVariableType VariableDeclaratorList{
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
        insertAttr(v, $3, "", 1);
		$$ = makenode("LocalVariableDeclaration", v);
    }
    ;

LocalVariableType
    : UnannType{$$=$1;}
    | VAR{$$ = makeleaf($1);}
    ;

Statement
    :StatementWithoutTrailingSubstatement{$$=$1;}
    |LabeledStatement{$$=$1;}
    |IfThenStatement{$$=$1;}
    |IfThenElseStatement{$$=$1;}
    |WhileStatement{$$=$1;}
    |ForStatement{$$=$1;}
    ;

StatementNoShortIf
    :StatementWithoutTrailingSubstatement{$$=$1;}
    |LabeledStatementNoShortIf{$$=$1;}
    |IfThenElseStatementNoShortIf{$$=$1;}
    |WhileStatementNoShortIf{$$=$1;}
    |ForStatementNoShortIf{$$=$1;}
    ;

StatementWithoutTrailingSubstatement
    :Block{$$=$1;}
    |';'{$$=makeleaf(";")}
    |ExpressionStatement{$$=$1;}
    |AssertStatement{$$=$1;}
    |BreakStatement{$$=$1;}
    |ContinueStatement{$$=$1;}
    |ReturnStatement{$$=$1;}
    |SynchronizedStatement{$$=$1;}
    |ThrowStatement{$$=$1;}
    |YieldStatement{$$=$1;}
    ;   

LabeledStatement
    :Identifier ':' Statement{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, ":", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("LabeledStatement", v);
    }
;

LabeledStatementNoShortIf
    :Identifier ':' StatementNoShortIf{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, ":", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("LabeledStatementNoShortIf", v);
    }
;

ExpressionStatement
    :StatementExpression ';'{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ExpressionStatement", v);
    }
;

StatementExpression
    :Assignment{$$=$1;}
    |PreIncrementExpression{$$=$1;}
    |PreDecrementExpression{$$=$1;}
    |PostIncrementExpression{$$=$1;}
    |PostDecrementExpression{$$=$1;}
    |MethodInvocation{$$=$1;}
    |ClassInstanceCreationExpression{$$=$1;}
;

IfThenStatement
    :IF '(' Expression ')' Statement{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$5, "", 1);
		$$ = makenode("IfThenStatement", v);
    }
;

IfThenElseStatement
    :IF '(' Expression ')' StatementNoShortIf ELSE Statement{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$5, "", 1);
        insertAttr(v,makeleaf($6), "", 1);
        insertAttr(v,$7, "", 1);
		$$ = makenode("IfThenElseStatement", v);
    }
;

IfThenElseStatementNoShortIf
    :IF '(' Expression ')' StatementNoShortIf ELSE StatementNoShortIf{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$5, "", 1);
        insertAttr(v,makeleaf($6), "", 1);
        insertAttr(v,$7, "", 1);
		$$ = makenode("IfThenElseStatementNoShortIf", v);
    }
;

AssertStatement
    :ASSERT Expression AssertStatement2 ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v,NULL, ";", 0);
		$$ = makenode("AssertStatement", v);
    }
;

AssertStatement2
    :%empty
    |':' Expression{
        vector<data>v;
        insertAttr(v, NULL, ":", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("AssertStatement2", v);
    }
;

WhileStatement
    : WHILE '(' Expression ')' Statement{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$5, "", 1);
		$$ = makenode("WhileStatement", v);
    }
;

WhileStatementNoShortIf
    :WHILE '(' Expression ')' StatementNoShortIf{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$5, "", 1);
		$$ = makenode("WhileStatementNoShortIf", v);
    }
;

ForStatement
    : BasicForHeader Statement{
        vector<data> v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("For_statement", v);
    }
    | EnhancedForHeader Statement{
        vector<data> v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("For_statement", v);
    }
;

ForStatementNoShortIf
    : BasicForHeader StatementNoShortIf{
        vector<data> v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("For_statement_no_short_if", v);
    }
    | EnhancedForHeader StatementNoShortIf{
        vector<data> v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("For_statement_no_short_if", v);
    }
;

BasicForHeader
    : FOR '(' ForInity ';' Expressiony ';' ForUpdatey ')' {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ";", 0);
        insertAttr(v,$5, "", 1);
        insertAttr(v, NULL, ";", 0);
        insertAttr(v,$7, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("Basic_For_Header", v);
    }

EnhancedForHeader
    : FOR '(' LocalVariableDeclaration ':' Expression ')' {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ";", 0);
        insertAttr(v,$5, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("Enhanced_For_Header", v);
    }

ForInity
    : %empty
    | ForInit {$$=$1;}
    ;

Expressiony
    : %empty
    | Expression {$$=$1;}
    ;

ForUpdatey
    : %empty
    | ForUpdate {$$=$1;}
    ;

ForInit
    :StatementExpressionList{$$=$1;}
    |LocalVariableDeclaration{$$=$1;}
;

ForUpdate
    :StatementExpressionList{$$=$1;}
;

StatementExpressionList
    :StatementExpression StatementExpressionList2{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("StatementExpressionList", v);
    }
;

StatementExpressionList2
    :%empty
    |',' StatementExpression StatementExpressionList2{
        vector<data>v;
        insertAttr(v, NULL, ",", 0);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3,"",1);
		$$ = makenode("StatementExpressionList2", v);
    }
;

BreakStatement
    :BREAK Identifieryy ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("BreakStatement", v);
    }
;

Identifieryy
    :%empty
    |Identifier{$$=makeleaf($1);}
;

YieldStatement
    :YIELD Expression ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("YieldStatement", v);
    }
;

ContinueStatement
    :CONTINUE Identifieryy ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ContinueStatement", v);
    }
;

ReturnStatement
    :RETURN Expressiony ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ReturnStatement", v);
    }
;

ThrowStatement
    :THROW Expression ';'{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ";", 0);
		$$ = makenode("ThrowStatement", v);
    }
;

SynchronizedStatement
    :SYNCHRONIZED '(' Expression ')' Block{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$5, "", 1);
		$$ = makenode("SynchronizedStatement", v);
    }
;

Finally
    :FINALLY Block{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("Finally", v);
    }
;

Pattern
    :TypePattern {$$=$1;}
;

TypePattern
    :LocalVariableDeclaration {$$=$1;}
;

//Grammar for Expressions

Primary
    :PrimaryNoNewArray{$$=$1;}
    |ArrayCreationExpression{$$ = $1;}
    ;
PrimaryNoNewArray
    :Literal{$$=$1;}
    |ClassLiteral{$$=$1;}
    |THIS {$$ = makeleaf($1;)}
    |TypeName '.' THIS{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v, makeleaf($3), "", 1);
		$$ = makenode("PrimaryNoNewArray", v);
    }
    |'(' Expression ')'{
        vector<data>v;
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("PrimaryNoNewArray", v);
    }
    |ClassInstanceCreationExpression{$$=$1;}
    |FieldAccess {$$=$1 ;}
    |ArrayAccess {$$ = $1;}
    |MethodInvocation {$$ = $1;}
    |MethodReference {$$ = $1;}
    ;
ClassLiteral
    :TypeName Brackets '.' CLASS{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v, makeleaf($4), "", 1);
		$$ = makenode("ClassLiteral", v);
    }
    |NumericType Brackets '.' CLASS{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v, makeleaf($4), "", 1);
		$$ = makenode("ClassLiteral", v);
    }
    |BOOLEAN Brackets '.' CLASS{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,makeleaf($4), "", 1);
		$$ = makenode("ClassLiteral", v);
    }
    |VOID '.' CLASS{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,makeleaf($3), "", 1);  
		$$ = makenode("ClassLiteral", v);
    }
    ;

Brackets
    :%empty
    |'[' ']' Brackets{
        vector<data>v;
        insertAttr(v, NULL, "[", 0);
        insertAttr(v, NULL, "]", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("Brackets", v);
    }
    ;

ClassInstanceCreationExpression
    :UnqualifiedClassInstanceCreationExpression {$$ = $1;}
    |ExpressionName '.' UnqualifiedClassInstanceCreationExpression{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ClassInstanceCreationExpression", v);
    }
    |Primary '.' UnqualifiedClassInstanceCreationExpression{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ClassInstanceCreationExpression", v);
    }
    ;
UnqualifiedClassInstanceCreationExpression
    :NEW TypeArgumentsy ClassOrInterfaceTypeToInstantiate '(' ArgumentListy ')' ClassBodyy {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, $2, "", 1);
        insertAttr(v, $3, "", 1);
        insertAttr(v, NULL, "(", 1);
        insertAttr(v, $5, "", 1);
        insertAttr(v, NULL, ")", 1);
        insertAttr(v, $7, "", 1);
		$$ = makenode("UnqualifiedClassInstanceCreationExpression", v);
    }
    ;

ClassOrInterfaceTypeToInstantiate
    : Annotations Identifier ClassOrInterfaceTypeToInstant TypeArgumentsOrDiamondy {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("ClassOrInterfaceTypeToInstantiate", v);
    }
    ;

TypeArgumentsOrDiamondy
    : %empty
    | TypeArgumentsOrDiamond {$$=$1;}
    ;

ClassOrInterfaceTypeToInstant
    : %empty
    | '.' Annotations Identifier ClassOrInterfaceTypeToInstant  {
        vector<data>v;
        insertAttr(v,NULL,".",0);
        insertAttr(v,$2, "", 1);
        insertAttr(v, makeleaf($3), "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("ClassOrInterfaceTypeToInstant", v);
    }
    ;

TypeArgumentsOrDiamond
    :TypeArguments{$$=$1;}
    |'<''>'{
        vector<data>v;
        insertAttr(v, NULL, "<", 0);
        insertAttr(v, NULL, ">", 0);
		$$ = makenode("TypeArgumentsOrDiamond", v);
    }
    ;

FieldAccess
    :Primary '.' Identifier{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v, makeleaf($3), "", 1);
		$$ = makenode("FieldAccess", v);
    }
    |SUPER '.' Identifier{
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,makeleaf($3), "", 1);
		$$ = makenode("FieldAccess", v);
    }
    |TypeName '.' SUPER '.' Identifier{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v, makeleaf($3), "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,makeleaf($5), "", 1);
		$$ = makenode("FieldAccess", v);
    }
    ;

ArrayAccess
    :ExpressionName '[' Expression ']' {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "[", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, "]", 0);
		$$ = makenode("ArrayAccess", v);
    }
    |PrimaryNoNewArray '[' Expression ']'{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "[", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, "]", 0);
		$$ = makenode("ArrayAccess", v);
    }

    ;

MethodInvocation
    :Identifier ArgumentListyy {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("MethodInvocation", v);
    }
    |TypeName '.' TypeArgumentsy Identifier ArgumentListyy {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v,makeleaf($4), "", 1);
        insertAttr(v,$5, "", 1);
		$$ = makenode("MethodInvocation", v);
    }
    |ExpressionName '.' TypeArgumentsy Identifier ArgumentListyy {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v,makeleaf($4), "", 1);
        insertAttr(v,$5, "", 1);
		$$ = makenode("MethodInvocation", v);
    }
    |Primary '.' TypeArgumentsy Identifier ArgumentListyy {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v,makeleaf($4), "", 1);
        insertAttr(v,$5, "", 1);
		$$ = makenode("MethodInvocation", v);
    }
    |SUPER '.' TypeArgumentsy Identifier ArgumentListyy {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v,makeleaf($4), "", 1);
        insertAttr(v,$5, "", 1);
		$$ = makenode("MethodInvocation", v);
    }
    |TypeName '.' SUPER '.' TypeArgumentsy Identifier ArgumentListyy {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v,makeleaf($3), "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v, $5 , "", 1);
        insertAttr(v, makeleaf($6), ".", 0);
        insertAttr(v,$7, "", 1);
		$$ = makenode("MethodInvocation", v);
    }
;

ArgumentList
    : Expression ArgumentList2 {
        vector<data> v;
        insertAttr(v, $1,"",1);
        insertAttr(v,$2,"",1);
        $$ = makenode("ArgumentList",v);
    }

ArgumentList2
    : %empty
    |',' Expression ArgumentList2 {
        vector<data>v;
        insertAttr(v,NULL, ",", 0);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ArgumentList", v);
    }
    ;

MethodReference
    :ExpressionName METHOD_REFERENCE TypeArgumentsy Identifier {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v, makeleaf($4), "", 1);
		$$ = makenode("MethodReference", v);
    }
    |Primary METHOD_REFERENCE TypeArgumentsy Identifier {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v, makeleaf($4), "", 1);
		$$ = makenode("MethodReference", v);
    }
    |ReferenceType METHOD_REFERENCE TypeArgumentsy Identifier{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v, makeleaf($4), "", 1);
		$$ = makenode("MethodReference", v);
    }
    |SUPER METHOD_REFERENCE TypeArgumentsy Identifier {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v, makeleaf($4), "", 1);
		$$ = makenode("MethodReference", v);
    }
    |TypeName '.' SUPER METHOD_REFERENCE TypeArgumentsy Identifier {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ".", 0);
        insertAttr(v, makeleaf($3), "", 1);
        insertAttr(v, makeleaf($4), "", 1);
        insertAttr(v,$5, "", 1);
        insertAttr(v, makeleaf($6), "", 1);
		$$ = makenode("MethodReference", v);
    }
    |ClassType METHOD_REFERENCE TypeArgumentsy NEW {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v, makeleaf($4), "", 1);
		$$ = makenode("MethodReference", v);
    }
    |ArrayType METHOD_REFERENCE NEW {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v,makeleaf($3), "", 1);
		$$ = makenode("MethodReference", v);
    }
    ;

ArrayCreationExpression
    :NEW PrimitiveType DimExprs Dimsy {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("ArrayCreationExpression", v);
    }
    |NEW ClassOrInterfaceType DimExprs Dimsy {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("ArrayCreationExpression", v);
    }
    |NEW PrimitiveType Dims ArrayInitializer {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("ArrayCreationExpression", v);
    }
    |NEW ClassOrInterfaceType Dims ArrayInitializer {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("ArrayCreationExpression", v);
    }
    ;

DimExprs
    :DimExpr DimExprs2 {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("DimExprs", v);
    }
    ;

DimExprs2
    :%empty
    |DimExpr DimExprs2 {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("DimExprs", v);
    }
    ;

DimExpr
    :Annotations '[' Expression ']' {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "[", 0);
        insertAttr(v,$3, "", 1);
        insertAttr(v, NULL, "]", 0);
		$$ = makenode("DimExpr", v);
    }
    ;

Expression
    :LambdaExpression {$$ = $1;}
    |AssignmentExpression {$$ = $1;}
    ;
LambdaExpression
    :LambdaParameters PTR_OP LambdaBody {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("LambdaExpression", v);
    }
    ;
LambdaParameters
    :'(' LambdaParameterListy ')' {
        vector<data>v;
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ")", 0);
		$$ = makenode("LambdaParameters", v);
    }
    |Identifier {$$ = makeleaf($1);}
    ;

LambdaParameterListy
    : %empty
    |LambdaParameterList  { $$=$1;
    }
    ;

LambdaParameterList
    :LambdaParameter LambdaParameterList2 {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("LambdaParameterList", v);
    }
    |Identifier Identifiers2 {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("LambdaParameterList", v);
    }
    ;
LambdaParameterList2
    :%empty 
    |',' LambdaParameterList {
        vector<data>v;
        insertAttr(v, NULL, ",", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("LambdaParameterList2", v);
    }

Identifiers2
    :%empty 
    |',' Identifier Identifiers2 {
        vector<data>v;
        insertAttr(v, NULL, ",", 0);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("Identifiers", v);
    }

LambdaParameter
    :VariableModifiers LambdaParameterType VariableDeclaratorId {
        vector<data>v;
        insertAttr(v, $1, "", 1);
        insertAttr(v, $2, "", 1);
        insertAttr(v, $3, "", 1);
		$$ = makenode("LambdaParameter", v);
    }
    |VariableArityParameter {$$ = $1;}
    ;

LambdaParameterType
    :UnannType {$$ = $1;}
    |VAR {$$=  makeleaf($1);}
    ;

LambdaBody
    :Expression {$$= $1;}
    |Block {$$=$1;}
    ;

AssignmentExpression
    :ConditionalExpression {$$ = $1;}
    |Assignment {$$ = $1;}
    ;

Assignment
    :LeftHandSide AssignmentOperator Expression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("Assignment", v);
    }
    ;

LeftHandSide
    :ExpressionName {$$ = $1;}
    |FieldAccess{$$=$1;}
    |ArrayAccess{$$=$1;}
    ;

AssignmentOperator
    :'='{$$ = makeleaf("=");}
    |MUL_ASSIGN {$$ = makeleaf($1);}
    |DIV_ASSIGN {$$ = makeleaf($1);}
    |MOD_ASSIGN{$$ = makeleaf($1);}
    |ADD_ASSIGN{$$ = makeleaf($1);}
    |SUB_ASSIGN{$$ = makeleaf($1);}
    |LEFT_ASSIGN{$$ = makeleaf($1);}
    |RIGHT_ASSIGN{$$ = makeleaf($1);}
    |UNSIGNED_RIGHT_ASSIGN{$$ = makeleaf($1);}
    |AND_ASSIGN{$$ = makeleaf($1);}
    |XOR_ASSIGN{$$ = makeleaf($1);}
    |OR_ASSIGN{$$ = makeleaf($1);}
;

ConditionalExpression
    :ConditionalOrExpression ConditionalExpression2{
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("ConditionalExpression", v);
    }
    ;

ConditionalExpression2
    :%empty 
    |'?' Expression ':' ConditionalExpression3 {
        vector<data>v;
        insertAttr(v, NULL, "?", 0);
        insertAttr(v,$2, "", 1);
        insertAttr(v, NULL, ":", 0);
        insertAttr(v,$4, "", 1);
		$$ = makenode("ConditionalExpression2", v);
    }
    ;

ConditionalExpression3
    :ConditionalExpression {$$ = $1 ;}
    |LambdaExpression { $$ = $1 ; }
    ;

ConditionalOrExpression
    :ConditionalAndExpression { $$ = $1 ; }
    |ConditionalOrExpression OR_OP ConditionalAndExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ConditionalOrExpression", v);
    }
    ;
ConditionalAndExpression
    :InclusiveOrExpression { $$ = $1 ;}
    |ConditionalAndExpression AND_OP InclusiveOrExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ConditionalAndExpression", v);
    }
    ;

InclusiveOrExpression
    :ExclusiveOrExpression {$$ = $1;}
    |InclusiveOrExpression '|' ExclusiveOrExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "|", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("InclusiveOrExpression", v);
    }
    ;
ExclusiveOrExpression
    :AndExpression {$$ = $1;}
    |ExclusiveOrExpression '^' AndExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "^", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("ExclusiveOrExpression", v);
    }
    ;

AndExpression
    :EqualityExpression {$$ = $1;}
    |AndExpression '&' EqualityExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, "&", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("AndExpression", v);
    }
    ;

EqualityExpression
    :RelationalExpression {$$ = $1 ;}
    |EqualityExpression EqualityExpression2 {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("EqualityExpression", v);
    }
    ;

EqualityExpression2 
    :EQ_OP RelationalExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("EqualityExpression2 ", v);
    }
    |NE_OP RelationalExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2 , "", 1);
		$$ = makenode("EqualityExpression2", v);
    }
    ;

RelationalExpression
    :ShiftExpression {$$ = $1;}
    |RelationalExpression RelationalExpression2 {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("RelationalExpression", v);
    } 
    |InstanceofExpression {$$ = $1;}
    ;

RelationalExpression2 
    :'<' ShiftExpression {
        vector<data>v;
        insertAttr(v, NULL, "<", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("RelationalExpression2", v);
    }
    |'>' ShiftExpression {
        vector<data>v;
        insertAttr(v, NULL, ">", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("RelationalExpression2", v);
    }
    |LE_OP ShiftExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("RelationalExpression2", v);
    }
    |GE_OP ShiftExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("RelationalExpression2", v);
    }
    ;

InstanceofExpression
    :RelationalExpression INSTANCEOF InstanceofExpression2 {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
        insertAttr(v,$3, "", 1);
		$$ = makenode("InstanceofExpression", v);
    }
    ;

InstanceofExpression2
    :ReferenceType {$$ = $1;}
    |Pattern {$$ = $1;}
    ;

ShiftExpression
    :AdditiveExpression {$$= $1;}
    |ShiftExpression ShiftExpression2 {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("ShiftExpression", v);
    }
    ;

ShiftExpression2
    :LEFT_OP AdditiveExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("ShiftExpression2", v);
    }
    |RIGHT_OP AdditiveExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("ShiftExpression2", v);
    }
    |UNSIGNED_RIGHT AdditiveExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("ShiftExpression2", v);
    }
    ;

AdditiveExpression
    :MultiplicativeExpression {$$ = $1;}
    |AdditiveExpression AdditiveExpression2 {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("AdditiveExpression", v);
    }
    ;

AdditiveExpression2
    :'+' MultiplicativeExpression {
        vector<data>v;
        insertAttr(v, NULL, "+", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("AdditiveExpression2", v);
    }
    |'-' MultiplicativeExpression {
        vector<data>v;
        insertAttr(v, NULL, "-", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("AdditiveExpression2", v);
    }
    ;

MultiplicativeExpression
    :UnaryExpression {$$ = $1;}
    |MultiplicativeExpression MultiplicativeExpressionSym UnaryExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v,$2, "", 1);
        insertAttr(v,$3,"",1);
		$$ = makenode("MultiplicativeExpression", v);
    }
    ;

MultiplicativeExpressionSym
    : '*' {$$=makeleaf("*");}
    | '/' {$$=makeleaf("/");}
    | '%' {$$=makeleaf("%");}
    ;

UnaryExpression
    :PreIncrementExpression {$$ = $1;}
    |PreDecrementExpression {$$ = $1;}
    |'+' UnaryExpression {
        vector<data>v;
        insertAttr(v, NULL, "+", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("UnaryExpression", v);
    }
    |'-' UnaryExpression {
        vector<data>v;
        insertAttr(v, NULL, "-", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("UnaryExpression", v);
    }
    |UnaryExpressionNotPlusMinus {$$ = $1;}
    ;

PreIncrementExpression
    :INC_OP UnaryExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("PreIncrementExpression", v);
    }
    ;

PreDecrementExpression
    :DEC_OP UnaryExpression {
        vector<data>v;
        insertAttr(v, makeleaf($1), "", 1);
        insertAttr(v,$2, "", 1);
		$$ = makenode("PreDecrementExpression", v);
    }
    ;

UnaryExpressionNotPlusMinus
    :PostfixExpression {$$ = $1;}
    |'~' UnaryExpression {
        vector<data>v;
        insertAttr(v, NULL, "~", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("UnaryExpressionNotPlusMinus", v);
    }
    |'!' UnaryExpression {
        vector<data>v;
        insertAttr(v, NULL, "!", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("UnaryExpressionNotPlusMinus", v);
    }
    |CastExpression {$$ = $1;}
    ;

PostfixExpression
    :Primary {$$ = $1;}
    |ExpressionName {$$ = $1;}
    |PostIncrementExpression { $$ = $1 ;}
    |PostDecrementExpression { $$ = $1 ;}
    ;

PostIncrementExpression
    :PostfixExpression INC_OP {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
		$$ = makenode("PostIncrementExpression", v);
    }
    ;

PostDecrementExpression
    :PostfixExpression DEC_OP {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, makeleaf($2), "", 1);
		$$ = makenode("PostDecrementExpression", v);
    }
    ;

CastExpression
    : '(' CastExpression2 {
        vector<data>v;
        insertAttr(v, NULL, "(", 0);
        insertAttr(v,$2, "", 1);
		$$ = makenode("CastExpression", v);
    }

CastExpression2
    :PrimitiveType ')' UnaryExpression {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, NULL, ")", 0);
        insertAttr(v,$3, "", 1);
		$$ = makenode("CastExpression2", v);
    }
    |ReferenceType AdditionalBounds ')' CastExpression3 {
        vector<data>v;
        insertAttr(v,$1, "", 1);
        insertAttr(v, $2, "", 1);
        insertAttr(v,NULL, ")", 1);
        insertAttr(v,$4, "", 1);
		$$ = makenode("CastExpression2", v);
    }
    ;
CastExpression3
    :UnaryExpressionNotPlusMinus { $$=$1;
    }
    |LambdaExpression { $$ = $1 ; }
    ;
    
ConstantExpression
    :Expression { $$ = $1 ;}
    ;

%%

int main(){
    dotfile = fopen("AST.dot", "w");
	
	if(dotfile == NULL){
		print_error();
		cout<<"cannot open the dot file AST.dot"<<"\nCompilation terminated\n";
		return -1;
	}

	beginAST();
    yyparse();
	endAST();

    return 0;
}

int yyerror(char const* s){
    cout << "Error: " << s << "in Line no: " << lineno << endl;
    return -1;
}

